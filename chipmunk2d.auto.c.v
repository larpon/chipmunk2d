// Copyright(C) 2021-2022 Lars Pontoppidan. All rights reserved.
// NOTE this file is auto-generated by cmd/gen_chipmunk_c.v
module chipmunk2d

import chipmunk2d.c

pub const used_import = c.used_import

//
// chipmunk.h
//

@[typedef]
struct C.cpArray {}

pub type Array = C.cpArray

@[typedef]
struct C.cpHashSet {}

pub type HashSet = C.cpHashSet

@[typedef]
struct C.cpBody {}

pub type Body = C.cpBody

@[typedef]
struct C.cpShape {}

pub type Shape = C.cpShape

@[typedef]
struct C.cpCircleShape {}

pub type CircleShape = C.cpCircleShape

@[typedef]
struct C.cpSegmentShape {}

pub type SegmentShape = C.cpSegmentShape

@[typedef]
struct C.cpPolyShape {}

pub type PolyShape = C.cpPolyShape

@[typedef]
struct C.cpConstraint {}

pub type Constraint = C.cpConstraint

@[typedef]
struct C.cpPinJoint {}

pub type PinJoint = C.cpPinJoint

@[typedef]
struct C.cpSlideJoint {}

pub type SlideJoint = C.cpSlideJoint

@[typedef]
struct C.cpPivotJoint {}

pub type PivotJoint = C.cpPivotJoint

@[typedef]
struct C.cpGrooveJoint {}

pub type GrooveJoint = C.cpGrooveJoint

@[typedef]
struct C.cpDampedSpring {}

pub type DampedSpring = C.cpDampedSpring

@[typedef]
struct C.cpDampedRotarySpring {}

pub type DampedRotarySpring = C.cpDampedRotarySpring

@[typedef]
struct C.cpRotaryLimitJoint {}

pub type RotaryLimitJoint = C.cpRotaryLimitJoint

@[typedef]
struct C.cpRatchetJoint {}

pub type RatchetJoint = C.cpRatchetJoint

@[typedef]
struct C.cpGearJoint {}

pub type GearJoint = C.cpGearJoint

@[typedef]
struct C.cpSimpleMotorJoint {}

pub type SimpleMotorJoint = C.cpSimpleMotorJoint

@[typedef]
struct C.cpCollisionHandler {}

pub type CollisionHandler = C.cpCollisionHandler

@[typedef]
struct C.cpContactPointSet {}

pub type ContactPointSet = C.cpContactPointSet

@[typedef]
struct C.cpArbiter {}

pub type Arbiter = C.cpArbiter

@[typedef]
struct C.cpSpace {}

pub type Space = C.cpSpace

// C signature:
// CP_EXPORT cpFloat cpMomentForCircle(cpFloat m, cpFloat r1, cpFloat r2, cpVect offset);
fn C.cpMomentForCircle(m Float, r1 Float, r2 Float, offset C.cpVect) Float

// moment_for_circle calculates the moment of inertia for a circle.
// @c r1 and @c r2 are the inner and outer diameters. A solid circle has an inner diameter of 0.
@[inline]
pub fn moment_for_circle(m Float, r1 Float, r2 Float, offset Vect) Float {
	return C.cpMomentForCircle(m, r1, r2, offset)
}

// C signature:
// CP_EXPORT cpFloat cpAreaForCircle(cpFloat r1, cpFloat r2);
fn C.cpAreaForCircle(r1 Float, r2 Float) Float

// area_for_circle calculates area of a hollow circle.
// @c r1 and @c r2 are the inner and outer diameters. A solid circle has an inner diameter of 0.
@[inline]
pub fn area_for_circle(r1 Float, r2 Float) Float {
	return C.cpAreaForCircle(r1, r2)
}

// C signature:
// CP_EXPORT cpFloat cpMomentForSegment(cpFloat m, cpVect a, cpVect b, cpFloat radius);
fn C.cpMomentForSegment(m Float, a C.cpVect, b C.cpVect, radius Float) Float

// moment_for_segment calculates the moment of inertia for a line segment.
// Beveling radius is not supported.
@[inline]
pub fn moment_for_segment(m Float, a Vect, b Vect, radius Float) Float {
	return C.cpMomentForSegment(m, a, b, radius)
}

// C signature:
// CP_EXPORT cpFloat cpAreaForSegment(cpVect a, cpVect b, cpFloat radius);
fn C.cpAreaForSegment(a C.cpVect, b C.cpVect, radius Float) Float

// area_for_segment calculates the area of a fattened (capsule shaped) line segment.
@[inline]
pub fn area_for_segment(a Vect, b Vect, radius Float) Float {
	return C.cpAreaForSegment(a, b, radius)
}

// C signature:
// CP_EXPORT cpFloat cpMomentForPoly(cpFloat m, int count, const cpVect *verts, cpVect offset, cpFloat radius);
fn C.cpMomentForPoly(m Float, count int, verts &C.cpVect, offset C.cpVect, radius Float) Float

// moment_for_poly calculates the moment of inertia for a solid polygon shape assuming it's center of gravity is at it's centroid. The offset is added to each vertex.
@[inline]
pub fn moment_for_poly(m Float, count int, verts &Vect, offset Vect, radius Float) Float {
	return C.cpMomentForPoly(m, count, verts, offset, radius)
}

// C signature:
// CP_EXPORT cpFloat cpAreaForPoly(const int count, const cpVect *verts, cpFloat radius);
fn C.cpAreaForPoly(count int, verts &C.cpVect, radius Float) Float

// area_for_poly calculates the signed area of a polygon. A Clockwise winding gives positive area.
// This is probably backwards from what you expect, but matches Chipmunk's the winding for poly shapes.
@[inline]
pub fn area_for_poly(count int, verts &Vect, radius Float) Float {
	return C.cpAreaForPoly(count, verts, radius)
}

// C signature:
// CP_EXPORT cpVect cpCentroidForPoly(const int count, const cpVect *verts);
fn C.cpCentroidForPoly(count int, verts &C.cpVect) C.cpVect

// centroid_for_poly calculates the natural centroid of a polygon.
@[inline]
pub fn centroid_for_poly(count int, verts &Vect) Vect {
	return C.cpCentroidForPoly(count, verts)
}

// C signature:
// CP_EXPORT cpFloat cpMomentForBox(cpFloat m, cpFloat width, cpFloat height);
fn C.cpMomentForBox(m Float, width Float, height Float) Float

// moment_for_box calculates the moment of inertia for a solid box.
@[inline]
pub fn moment_for_box(m Float, width Float, height Float) Float {
	return C.cpMomentForBox(m, width, height)
}

// C signature:
// CP_EXPORT cpFloat cpMomentForBox2(cpFloat m, cpBB box);
fn C.cpMomentForBox2(m Float, box C.cpBB) Float

// moment_for_box2 calculates the moment of inertia for a solid box.
@[inline]
pub fn moment_for_box2(m Float, box BB) Float {
	return C.cpMomentForBox2(m, box)
}

// C signature:
// CP_EXPORT int cpConvexHull(int count, const cpVect *verts, cpVect *result, int *first, cpFloat tol);
fn C.cpConvexHull(count int, verts &C.cpVect, result &C.cpVect, first &int, tol Float) int

// convex_hull calculates the convex hull of a given set of points. Returns the count of points in the hull.
// @c result must be a pointer to a @c cpVect array with at least @c count elements. If @c verts == @c result, then @c verts will be reduced inplace.
// @c first is an optional pointer to an integer to store where the first vertex in the hull came from (i.e. verts[first] == result[0])
// @c tol is the allowed amount to shrink the hull when simplifying it. A tolerance of 0.0 creates an exact hull.
@[inline]
pub fn convex_hull(count int, verts &Vect, result &Vect, first int, tol Float) int {
	return C.cpConvexHull(count, verts, result, first, tol)
}

//
// chipmunk_ffi.h
//

//
// chipmunk_private.h
//

//
// chipmunk_structs.h
//

@[typedef]
struct C.cpShapeClass {}

pub type ShapeClass = C.cpShapeClass

@[typedef]
struct C.cpConstraintClass {}

pub type ConstraintClass = C.cpConstraintClass

@[typedef]
struct C.cpContactBufferHeader {}

pub type ContactBufferHeader = C.cpContactBufferHeader

@[typedef]
struct C.cpPostStepCallback {}

pub type PostStepCallback = C.cpPostStepCallback

//
// chipmunk_types.h
//

type Float = f64

@[typedef]
struct C.cpVect {
pub mut:
	x Float
	y Float
}

pub type Vect = C.cpVect

pub const vzero = Vect{0.0, 0.0}

@[typedef]
struct C.cpMat2x2 {}

pub type Mat2x2 = C.cpMat2x2

//
// chipmunk_unsafe.h
//

// C signature:
// CP_EXPORT void cpCircleShapeSetRadius(cpShape *shape, cpFloat radius);
fn C.cpCircleShapeSetRadius(shape &C.cpShape, radius Float)

// circle_shape_set_radius sets the radius of a circle shape.
@[inline]
pub fn circle_shape_set_radius(shape &Shape, radius Float) {
	C.cpCircleShapeSetRadius(shape, radius)
}

// C signature:
// CP_EXPORT void cpCircleShapeSetOffset(cpShape *shape, cpVect offset);
fn C.cpCircleShapeSetOffset(shape &C.cpShape, offset C.cpVect)

// circle_shape_set_offset sets the offset of a circle shape.
@[inline]
pub fn circle_shape_set_offset(shape &Shape, offset Vect) {
	C.cpCircleShapeSetOffset(shape, offset)
}

// C signature:
// CP_EXPORT void cpSegmentShapeSetEndpoints(cpShape *shape, cpVect a, cpVect b);
fn C.cpSegmentShapeSetEndpoints(shape &C.cpShape, a C.cpVect, b C.cpVect)

// segment_shape_set_endpoints sets the endpoints of a segment shape.
@[inline]
pub fn segment_shape_set_endpoints(shape &Shape, a Vect, b Vect) {
	C.cpSegmentShapeSetEndpoints(shape, a, b)
}

// C signature:
// CP_EXPORT void cpSegmentShapeSetRadius(cpShape *shape, cpFloat radius);
fn C.cpSegmentShapeSetRadius(shape &C.cpShape, radius Float)

// segment_shape_set_radius sets the radius of a segment shape.
@[inline]
pub fn segment_shape_set_radius(shape &Shape, radius Float) {
	C.cpSegmentShapeSetRadius(shape, radius)
}

// C signature:
// CP_EXPORT void cpPolyShapeSetVerts(cpShape *shape, int count, cpVect *verts, cpTransform transform);
fn C.cpPolyShapeSetVerts(shape &C.cpShape, count int, verts &C.cpVect, transform C.cpTransform)

// poly_shape_set_verts sets the vertexes of a poly shape.
@[inline]
pub fn poly_shape_set_verts(shape &Shape, count int, verts &Vect, transform C.cpTransform) {
	C.cpPolyShapeSetVerts(shape, count, verts, transform)
}

// C signature:
// CP_EXPORT void cpPolyShapeSetVertsRaw(cpShape *shape, int count, cpVect *verts);
fn C.cpPolyShapeSetVertsRaw(shape &C.cpShape, count int, verts &C.cpVect)
@[inline]
pub fn poly_shape_set_verts_raw(shape &Shape, count int, verts &Vect) {
	C.cpPolyShapeSetVertsRaw(shape, count, verts)
}

// C signature:
// CP_EXPORT void cpPolyShapeSetRadius(cpShape *shape, cpFloat radius);
fn C.cpPolyShapeSetRadius(shape &C.cpShape, radius Float)

// poly_shape_set_radius sets the radius of a poly shape.
@[inline]
pub fn poly_shape_set_radius(shape &Shape, radius Float) {
	C.cpPolyShapeSetRadius(shape, radius)
}

//
// cpArbiter.h
//

// C signature:
// CP_EXPORT cpFloat cpArbiterGetRestitution(const cpArbiter *arb);
fn C.cpArbiterGetRestitution(arb &C.cpArbiter) Float

// get_restitution gets the restitution (elasticity) that will be applied to the pair of colliding objects.
@[inline]
pub fn (mut arb Arbiter) get_restitution() Float {
	return C.cpArbiterGetRestitution(arb)
}

// C signature:
// CP_EXPORT void cpArbiterSetRestitution(cpArbiter *arb, cpFloat restitution);
fn C.cpArbiterSetRestitution(arb &C.cpArbiter, restitution Float)

// set_restitution overrides the restitution (elasticity) that will be applied to the pair of colliding objects.
@[inline]
pub fn (mut arb Arbiter) set_restitution(restitution Float) {
	C.cpArbiterSetRestitution(arb, restitution)
}

// C signature:
// CP_EXPORT cpFloat cpArbiterGetFriction(const cpArbiter *arb);
fn C.cpArbiterGetFriction(arb &C.cpArbiter) Float

// get_friction gets the friction coefficient that will be applied to the pair of colliding objects.
@[inline]
pub fn (mut arb Arbiter) get_friction() Float {
	return C.cpArbiterGetFriction(arb)
}

// C signature:
// CP_EXPORT void cpArbiterSetFriction(cpArbiter *arb, cpFloat friction);
fn C.cpArbiterSetFriction(arb &C.cpArbiter, friction Float)

// set_friction overrides the friction coefficient that will be applied to the pair of colliding objects.
@[inline]
pub fn (mut arb Arbiter) set_friction(friction Float) {
	C.cpArbiterSetFriction(arb, friction)
}

// C signature:
// CP_EXPORT cpVect cpArbiterGetSurfaceVelocity(cpArbiter *arb);
fn C.cpArbiterGetSurfaceVelocity(arb &C.cpArbiter) C.cpVect
@[inline]
pub fn (mut arb Arbiter) get_surface_velocity() Vect {
	return C.cpArbiterGetSurfaceVelocity(arb)
}

// C signature:
// CP_EXPORT void cpArbiterSetSurfaceVelocity(cpArbiter *arb, cpVect vr);
fn C.cpArbiterSetSurfaceVelocity(arb &C.cpArbiter, vr C.cpVect)
@[inline]
pub fn (mut arb Arbiter) set_surface_velocity(vr Vect) {
	C.cpArbiterSetSurfaceVelocity(arb, vr)
}

// C signature:
// CP_EXPORT cpDataPointer cpArbiterGetUserData(const cpArbiter *arb);
fn C.cpArbiterGetUserData(arb &C.cpArbiter) C.cpDataPointer

// get_user_data gets the user data pointer associated with this pair of colliding objects.
@[inline]
pub fn (mut arb Arbiter) get_user_data() C.cpDataPointer {
	return C.cpArbiterGetUserData(arb)
}

// C signature:
// CP_EXPORT void cpArbiterSetUserData(cpArbiter *arb, cpDataPointer userData);
fn C.cpArbiterSetUserData(arb &C.cpArbiter, userData C.cpDataPointer)

// set_user_data sets a user data point associated with this pair of colliding objects.
// If you need to perform any cleanup for this pointer, you must do it yourself, in the separate callback for instance.
@[inline]
pub fn (mut arb Arbiter) set_user_data(userData C.cpDataPointer) {
	C.cpArbiterSetUserData(arb, userData)
}

// C signature:
// CP_EXPORT cpVect cpArbiterTotalImpulse(const cpArbiter *arb);
fn C.cpArbiterTotalImpulse(arb &C.cpArbiter) C.cpVect

// total_impulse calculates the total impulse including the friction that was applied by this arbiter.
// This function should only be called from a post-solve, post-step or cpBodyEachArbiter callback.
@[inline]
pub fn (mut arb Arbiter) total_impulse() Vect {
	return C.cpArbiterTotalImpulse(arb)
}

// C signature:
// CP_EXPORT cpFloat cpArbiterTotalKE(const cpArbiter *arb);
fn C.cpArbiterTotalKE(arb &C.cpArbiter) Float

// total_k_e calculates the amount of energy lost in a collision including static, but not dynamic friction.
// This function should only be called from a post-solve, post-step or cpBodyEachArbiter callback.
@[inline]
pub fn (mut arb Arbiter) total_k_e() Float {
	return C.cpArbiterTotalKE(arb)
}

// C signature:
// CP_EXPORT cpBool cpArbiterIgnore(cpArbiter *arb);
fn C.cpArbiterIgnore(arb &C.cpArbiter) bool

// ignore marks a collision pair to be ignored until the two objects separate.
// Pre-solve and post-solve callbacks will not be called, but the separate callback will be called.
@[inline]
pub fn (mut arb Arbiter) ignore() bool {
	return C.cpArbiterIgnore(arb)
}

// C signature:
// CP_EXPORT void cpArbiterGetShapes(const cpArbiter *arb, cpShape **a, cpShape **b);
fn C.cpArbiterGetShapes(arb &C.cpArbiter, a &&C.cpShape, b &&C.cpShape)

// get_shapes returns the colliding shapes involved for this arbiter.
// The order of their cpSpace.collision_type values will match
// the order set when the collision handler was registered.
@[inline]
pub fn (mut arb Arbiter) get_shapes(a &&Shape, b &&Shape) {
	C.cpArbiterGetShapes(arb, a, b)
}

// C signature:
// CP_EXPORT void cpArbiterGetBodies(const cpArbiter *arb, cpBody **a, cpBody **b);
fn C.cpArbiterGetBodies(arb &C.cpArbiter, a &&C.cpBody, b &&C.cpBody)

// get_bodies returns the colliding bodies involved for this arbiter.
// The order of the cpSpace.collision_type the bodies are associated with values will match
// the order set when the collision handler was registered.
@[inline]
pub fn (mut arb Arbiter) get_bodies(a &&Body, b &&Body) {
	C.cpArbiterGetBodies(arb, a, b)
}

// C signature:
// CP_EXPORT cpContactPointSet cpArbiterGetContactPointSet(const cpArbiter *arb);
fn C.cpArbiterGetContactPointSet(arb &C.cpArbiter) C.cpContactPointSet

// get_contact_point_set returns a contact set from an arbiter.
@[inline]
pub fn (mut arb Arbiter) get_contact_point_set() ContactPointSet {
	return C.cpArbiterGetContactPointSet(arb)
}

// C signature:
// CP_EXPORT void cpArbiterSetContactPointSet(cpArbiter *arb, cpContactPointSet *set);
fn C.cpArbiterSetContactPointSet(arb &C.cpArbiter, set &C.cpContactPointSet)

// set_contact_point_set replaces the contact point set for an arbiter.
// This can be a very powerful feature, but use it with caution!
@[inline]
pub fn (mut arb Arbiter) set_contact_point_set(set &ContactPointSet) {
	C.cpArbiterSetContactPointSet(arb, set)
}

// C signature:
// CP_EXPORT cpBool cpArbiterIsFirstContact(const cpArbiter *arb);
fn C.cpArbiterIsFirstContact(arb &C.cpArbiter) bool

// is_first_contact returnss true if this is the first step a pair of objects started colliding.
@[inline]
pub fn (mut arb Arbiter) is_first_contact() bool {
	return C.cpArbiterIsFirstContact(arb)
}

// C signature:
// CP_EXPORT cpBool cpArbiterIsRemoval(const cpArbiter *arb);
fn C.cpArbiterIsRemoval(arb &C.cpArbiter) bool

// is_removal returnss true if the separate callback is due to a shape being removed from the space.
@[inline]
pub fn (mut arb Arbiter) is_removal() bool {
	return C.cpArbiterIsRemoval(arb)
}

// C signature:
// CP_EXPORT int cpArbiterGetCount(const cpArbiter *arb);
fn C.cpArbiterGetCount(arb &C.cpArbiter) int

// get_count gets the number of contact points for this arbiter.
@[inline]
pub fn (mut arb Arbiter) get_count() int {
	return C.cpArbiterGetCount(arb)
}

// C signature:
// CP_EXPORT cpVect cpArbiterGetNormal(const cpArbiter *arb);
fn C.cpArbiterGetNormal(arb &C.cpArbiter) C.cpVect

// get_normal gets the normal of the collision.
@[inline]
pub fn (mut arb Arbiter) get_normal() Vect {
	return C.cpArbiterGetNormal(arb)
}

// C signature:
// CP_EXPORT cpVect cpArbiterGetPointA(const cpArbiter *arb, int i);
fn C.cpArbiterGetPointA(arb &C.cpArbiter, i int) C.cpVect

// get_point_a gets the position of the @c ith contact point on the surface of the first shape.
@[inline]
pub fn (mut arb Arbiter) get_point_a(i int) Vect {
	return C.cpArbiterGetPointA(arb, i)
}

// C signature:
// CP_EXPORT cpVect cpArbiterGetPointB(const cpArbiter *arb, int i);
fn C.cpArbiterGetPointB(arb &C.cpArbiter, i int) C.cpVect

// get_point_b gets the position of the @c ith contact point on the surface of the second shape.
@[inline]
pub fn (mut arb Arbiter) get_point_b(i int) Vect {
	return C.cpArbiterGetPointB(arb, i)
}

// C signature:
// CP_EXPORT cpFloat cpArbiterGetDepth(const cpArbiter *arb, int i);
fn C.cpArbiterGetDepth(arb &C.cpArbiter, i int) Float

// get_depth gets the depth of the @c ith contact point.
@[inline]
pub fn (mut arb Arbiter) get_depth(i int) Float {
	return C.cpArbiterGetDepth(arb, i)
}

// C signature:
// CP_EXPORT cpBool cpArbiterCallWildcardBeginA(cpArbiter *arb, cpSpace *space);
fn C.cpArbiterCallWildcardBeginA(arb &C.cpArbiter, space &C.cpSpace) bool

// call_wildcard_begin_a ifs you want a custom callback to invoke the wildcard callback for the first collision type, you must call this function explicitly.
// You must decide how to handle the wildcard's return value since it may disagree with the other wildcard handler's return value or your own.
@[inline]
pub fn (mut arb Arbiter) call_wildcard_begin_a(space &Space) bool {
	return C.cpArbiterCallWildcardBeginA(arb, space)
}

// C signature:
// CP_EXPORT cpBool cpArbiterCallWildcardBeginB(cpArbiter *arb, cpSpace *space);
fn C.cpArbiterCallWildcardBeginB(arb &C.cpArbiter, space &C.cpSpace) bool

// call_wildcard_begin_b ifs you want a custom callback to invoke the wildcard callback for the second collision type, you must call this function explicitly.
// You must decide how to handle the wildcard's return value since it may disagree with the other wildcard handler's return value or your own.
@[inline]
pub fn (mut arb Arbiter) call_wildcard_begin_b(space &Space) bool {
	return C.cpArbiterCallWildcardBeginB(arb, space)
}

// C signature:
// CP_EXPORT cpBool cpArbiterCallWildcardPreSolveA(cpArbiter *arb, cpSpace *space);
fn C.cpArbiterCallWildcardPreSolveA(arb &C.cpArbiter, space &C.cpSpace) bool

// call_wildcard_pre_solve_a ifs you want a custom callback to invoke the wildcard callback for the first collision type, you must call this function explicitly.
// You must decide how to handle the wildcard's return value since it may disagree with the other wildcard handler's return value or your own.
@[inline]
pub fn (mut arb Arbiter) call_wildcard_pre_solve_a(space &Space) bool {
	return C.cpArbiterCallWildcardPreSolveA(arb, space)
}

// C signature:
// CP_EXPORT cpBool cpArbiterCallWildcardPreSolveB(cpArbiter *arb, cpSpace *space);
fn C.cpArbiterCallWildcardPreSolveB(arb &C.cpArbiter, space &C.cpSpace) bool

// call_wildcard_pre_solve_b ifs you want a custom callback to invoke the wildcard callback for the second collision type, you must call this function explicitly.
// You must decide how to handle the wildcard's return value since it may disagree with the other wildcard handler's return value or your own.
@[inline]
pub fn (mut arb Arbiter) call_wildcard_pre_solve_b(space &Space) bool {
	return C.cpArbiterCallWildcardPreSolveB(arb, space)
}

// C signature:
// CP_EXPORT void cpArbiterCallWildcardPostSolveA(cpArbiter *arb, cpSpace *space);
fn C.cpArbiterCallWildcardPostSolveA(arb &C.cpArbiter, space &C.cpSpace)

// call_wildcard_post_solve_a ifs you want a custom callback to invoke the wildcard callback for the first collision type, you must call this function explicitly.
@[inline]
pub fn (mut arb Arbiter) call_wildcard_post_solve_a(space &Space) {
	C.cpArbiterCallWildcardPostSolveA(arb, space)
}

// C signature:
// CP_EXPORT void cpArbiterCallWildcardPostSolveB(cpArbiter *arb, cpSpace *space);
fn C.cpArbiterCallWildcardPostSolveB(arb &C.cpArbiter, space &C.cpSpace)

// call_wildcard_post_solve_b ifs you want a custom callback to invoke the wildcard callback for the second collision type, you must call this function explicitly.
@[inline]
pub fn (mut arb Arbiter) call_wildcard_post_solve_b(space &Space) {
	C.cpArbiterCallWildcardPostSolveB(arb, space)
}

// C signature:
// CP_EXPORT void cpArbiterCallWildcardSeparateA(cpArbiter *arb, cpSpace *space);
fn C.cpArbiterCallWildcardSeparateA(arb &C.cpArbiter, space &C.cpSpace)

// call_wildcard_separate_a ifs you want a custom callback to invoke the wildcard callback for the first collision type, you must call this function explicitly.
@[inline]
pub fn (mut arb Arbiter) call_wildcard_separate_a(space &Space) {
	C.cpArbiterCallWildcardSeparateA(arb, space)
}

// C signature:
// CP_EXPORT void cpArbiterCallWildcardSeparateB(cpArbiter *arb, cpSpace *space);
fn C.cpArbiterCallWildcardSeparateB(arb &C.cpArbiter, space &C.cpSpace)

// call_wildcard_separate_b ifs you want a custom callback to invoke the wildcard callback for the second collision type, you must call this function explicitly.
@[inline]
pub fn (mut arb Arbiter) call_wildcard_separate_b(space &Space) {
	C.cpArbiterCallWildcardSeparateB(arb, space)
}

//
// cpBB.h
//

@[typedef]
struct C.cpBB {}

pub type BB = C.cpBB

//
// cpBody.h
//

// C signature:
// CP_EXPORT cpBody* cpBodyAlloc();
fn C.cpBodyAlloc() &C.cpBody

// body_alloc allocates a cpBody.
@[inline]
pub fn body_alloc() &Body {
	return C.cpBodyAlloc()
}

// C signature:
// CP_EXPORT cpBody* cpBodyInit(cpBody *body, cpFloat mass, cpFloat moment);
fn C.cpBodyInit(body &C.cpBody, mass Float, moment Float) &C.cpBody

// init initializes a cpBody.
@[inline]
pub fn (mut body Body) init(mass Float, moment Float) &Body {
	return C.cpBodyInit(body, mass, moment)
}

// C signature:
// CP_EXPORT cpBody* cpBodyNew(cpFloat mass, cpFloat moment);
fn C.cpBodyNew(mass Float, moment Float) &C.cpBody

// body_new allocates and initialize a cpBody.
@[inline]
pub fn body_new(mass Float, moment Float) &Body {
	return C.cpBodyNew(mass, moment)
}

// C signature:
// CP_EXPORT cpBody* cpBodyNewKinematic();
fn C.cpBodyNewKinematic() &C.cpBody

// body_new_kinematic allocates and initialize a cpBody, and set it as a kinematic body.
@[inline]
pub fn body_new_kinematic() &Body {
	return C.cpBodyNewKinematic()
}

// C signature:
// CP_EXPORT cpBody* cpBodyNewStatic();
fn C.cpBodyNewStatic() &C.cpBody

// body_new_static allocates and initialize a cpBody, and set it as a static body.
@[inline]
pub fn body_new_static() &Body {
	return C.cpBodyNewStatic()
}

// C signature:
// CP_EXPORT void cpBodyDestroy(cpBody *body);
fn C.cpBodyDestroy(body &C.cpBody)

// destroy destroys a cpBody.
@[inline]
pub fn (mut body Body) destroy() {
	C.cpBodyDestroy(body)
}

// C signature:
// CP_EXPORT void cpBodyFree(cpBody *body);
fn C.cpBodyFree(body &C.cpBody)

// free destroys and free a cpBody.
@[inline]
pub fn (mut body Body) free() {
	C.cpBodyFree(body)
}

// C signature:
// CP_EXPORT void cpBodyActivate(cpBody *body);
fn C.cpBodyActivate(body &C.cpBody)

// activate wakes up a sleeping or idle body.
@[inline]
pub fn (mut body Body) activate() {
	C.cpBodyActivate(body)
}

// C signature:
// CP_EXPORT void cpBodyActivateStatic(cpBody *body, cpShape *filter);
fn C.cpBodyActivateStatic(body &C.cpBody, filter &C.cpShape)

// activate_static wakes up any sleeping or idle bodies touching a static body.
@[inline]
pub fn (mut body Body) activate_static(filter &Shape) {
	C.cpBodyActivateStatic(body, filter)
}

// C signature:
// CP_EXPORT void cpBodySleep(cpBody *body);
fn C.cpBodySleep(body &C.cpBody)

// sleep forces a body to fall asleep immediately.
@[inline]
pub fn (mut body Body) sleep() {
	C.cpBodySleep(body)
}

// C signature:
// CP_EXPORT void cpBodySleepWithGroup(cpBody *body, cpBody *group);
fn C.cpBodySleepWithGroup(body &C.cpBody, group &C.cpBody)

// sleep_with_group forces a body to fall asleep immediately along with other bodies in a group.
@[inline]
pub fn (mut body Body) sleep_with_group(group &Body) {
	C.cpBodySleepWithGroup(body, group)
}

// C signature:
// CP_EXPORT cpBool cpBodyIsSleeping(const cpBody *body);
fn C.cpBodyIsSleeping(body &C.cpBody) bool

// is_sleeping returnss true if the body is sleeping.
@[inline]
pub fn (mut body Body) is_sleeping() bool {
	return C.cpBodyIsSleeping(body)
}

// C signature:
// CP_EXPORT cpBodyType cpBodyGetType(cpBody *body);
fn C.cpBodyGetType(body &C.cpBody) C.cpBodyType

// get_type gets the type of the body.
@[inline]
pub fn (mut body Body) get_type() C.cpBodyType {
	return C.cpBodyGetType(body)
}

// C signature:
// CP_EXPORT void cpBodySetType(cpBody *body, cpBodyType type);
fn C.cpBodySetType(body &C.cpBody, typ C.cpBodyType)

// set_type sets the type of the body.
@[inline]
pub fn (mut body Body) set_type(typ C.cpBodyType) {
	C.cpBodySetType(body, typ)
}

// C signature:
// CP_EXPORT cpSpace* cpBodyGetSpace(const cpBody *body);
fn C.cpBodyGetSpace(body &C.cpBody) &C.cpSpace

// get_space gets the space this body is added to.
@[inline]
pub fn (mut body Body) get_space() &Space {
	return C.cpBodyGetSpace(body)
}

// C signature:
// CP_EXPORT cpFloat cpBodyGetMass(const cpBody *body);
fn C.cpBodyGetMass(body &C.cpBody) Float

// get_mass gets the mass of the body.
@[inline]
pub fn (mut body Body) get_mass() Float {
	return C.cpBodyGetMass(body)
}

// C signature:
// CP_EXPORT void cpBodySetMass(cpBody *body, cpFloat m);
fn C.cpBodySetMass(body &C.cpBody, m Float)

// set_mass sets the mass of the body.
@[inline]
pub fn (mut body Body) set_mass(m Float) {
	C.cpBodySetMass(body, m)
}

// C signature:
// CP_EXPORT cpFloat cpBodyGetMoment(const cpBody *body);
fn C.cpBodyGetMoment(body &C.cpBody) Float

// get_moment gets the moment of inertia of the body.
@[inline]
pub fn (mut body Body) get_moment() Float {
	return C.cpBodyGetMoment(body)
}

// C signature:
// CP_EXPORT void cpBodySetMoment(cpBody *body, cpFloat i);
fn C.cpBodySetMoment(body &C.cpBody, i Float)

// set_moment sets the moment of inertia of the body.
@[inline]
pub fn (mut body Body) set_moment(i Float) {
	C.cpBodySetMoment(body, i)
}

// C signature:
// CP_EXPORT cpVect cpBodyGetPosition(const cpBody *body);
fn C.cpBodyGetPosition(body &C.cpBody) C.cpVect

// get_position sets the position of a body.
@[inline]
pub fn (mut body Body) get_position() Vect {
	return C.cpBodyGetPosition(body)
}

// C signature:
// CP_EXPORT void cpBodySetPosition(cpBody *body, cpVect pos);
fn C.cpBodySetPosition(body &C.cpBody, pos C.cpVect)

// set_position sets the position of the body.
@[inline]
pub fn (mut body Body) set_position(pos Vect) {
	C.cpBodySetPosition(body, pos)
}

// C signature:
// CP_EXPORT cpVect cpBodyGetCenterOfGravity(const cpBody *body);
fn C.cpBodyGetCenterOfGravity(body &C.cpBody) C.cpVect

// get_center_of_gravity gets the offset of the center of gravity in body local coordinates.
@[inline]
pub fn (mut body Body) get_center_of_gravity() Vect {
	return C.cpBodyGetCenterOfGravity(body)
}

// C signature:
// CP_EXPORT void cpBodySetCenterOfGravity(cpBody *body, cpVect cog);
fn C.cpBodySetCenterOfGravity(body &C.cpBody, cog C.cpVect)

// set_center_of_gravity sets the offset of the center of gravity in body local coordinates.
@[inline]
pub fn (mut body Body) set_center_of_gravity(cog Vect) {
	C.cpBodySetCenterOfGravity(body, cog)
}

// C signature:
// CP_EXPORT cpVect cpBodyGetVelocity(const cpBody *body);
fn C.cpBodyGetVelocity(body &C.cpBody) C.cpVect

// get_velocity gets the velocity of the body.
@[inline]
pub fn (mut body Body) get_velocity() Vect {
	return C.cpBodyGetVelocity(body)
}

// C signature:
// CP_EXPORT void cpBodySetVelocity(cpBody *body, cpVect velocity);
fn C.cpBodySetVelocity(body &C.cpBody, velocity C.cpVect)

// set_velocity sets the velocity of the body.
@[inline]
pub fn (mut body Body) set_velocity(velocity Vect) {
	C.cpBodySetVelocity(body, velocity)
}

// C signature:
// CP_EXPORT cpVect cpBodyGetForce(const cpBody *body);
fn C.cpBodyGetForce(body &C.cpBody) C.cpVect

// get_force gets the force applied to the body for the next time step.
@[inline]
pub fn (mut body Body) get_force() Vect {
	return C.cpBodyGetForce(body)
}

// C signature:
// CP_EXPORT void cpBodySetForce(cpBody *body, cpVect force);
fn C.cpBodySetForce(body &C.cpBody, force C.cpVect)

// set_force sets the force applied to the body for the next time step.
@[inline]
pub fn (mut body Body) set_force(force Vect) {
	C.cpBodySetForce(body, force)
}

// C signature:
// CP_EXPORT cpFloat cpBodyGetAngle(const cpBody *body);
fn C.cpBodyGetAngle(body &C.cpBody) Float

// get_angle gets the angle of the body.
@[inline]
pub fn (mut body Body) get_angle() Float {
	return C.cpBodyGetAngle(body)
}

// C signature:
// CP_EXPORT void cpBodySetAngle(cpBody *body, cpFloat a);
fn C.cpBodySetAngle(body &C.cpBody, a Float)

// set_angle sets the angle of a body.
@[inline]
pub fn (mut body Body) set_angle(a Float) {
	C.cpBodySetAngle(body, a)
}

// C signature:
// CP_EXPORT cpFloat cpBodyGetAngularVelocity(const cpBody *body);
fn C.cpBodyGetAngularVelocity(body &C.cpBody) Float

// get_angular_velocity gets the angular velocity of the body.
@[inline]
pub fn (mut body Body) get_angular_velocity() Float {
	return C.cpBodyGetAngularVelocity(body)
}

// C signature:
// CP_EXPORT void cpBodySetAngularVelocity(cpBody *body, cpFloat angularVelocity);
fn C.cpBodySetAngularVelocity(body &C.cpBody, angularVelocity Float)

// set_angular_velocity sets the angular velocity of the body.
@[inline]
pub fn (mut body Body) set_angular_velocity(angularVelocity Float) {
	C.cpBodySetAngularVelocity(body, angularVelocity)
}

// C signature:
// CP_EXPORT cpFloat cpBodyGetTorque(const cpBody *body);
fn C.cpBodyGetTorque(body &C.cpBody) Float

// get_torque gets the torque applied to the body for the next time step.
@[inline]
pub fn (mut body Body) get_torque() Float {
	return C.cpBodyGetTorque(body)
}

// C signature:
// CP_EXPORT void cpBodySetTorque(cpBody *body, cpFloat torque);
fn C.cpBodySetTorque(body &C.cpBody, torque Float)

// set_torque sets the torque applied to the body for the next time step.
@[inline]
pub fn (mut body Body) set_torque(torque Float) {
	C.cpBodySetTorque(body, torque)
}

// C signature:
// CP_EXPORT cpVect cpBodyGetRotation(const cpBody *body);
fn C.cpBodyGetRotation(body &C.cpBody) C.cpVect

// get_rotation gets the rotation vector of the body. (The x basis vector of it's transform.)
@[inline]
pub fn (mut body Body) get_rotation() Vect {
	return C.cpBodyGetRotation(body)
}

// C signature:
// CP_EXPORT cpDataPointer cpBodyGetUserData(const cpBody *body);
fn C.cpBodyGetUserData(body &C.cpBody) C.cpDataPointer

// get_user_data gets the user data pointer assigned to the body.
@[inline]
pub fn (mut body Body) get_user_data() C.cpDataPointer {
	return C.cpBodyGetUserData(body)
}

// C signature:
// CP_EXPORT void cpBodySetUserData(cpBody *body, cpDataPointer userData);
fn C.cpBodySetUserData(body &C.cpBody, userData C.cpDataPointer)

// set_user_data sets the user data pointer assigned to the body.
@[inline]
pub fn (mut body Body) set_user_data(userData C.cpDataPointer) {
	C.cpBodySetUserData(body, userData)
}

// C signature:
// CP_EXPORT void cpBodySetVelocityUpdateFunc(cpBody *body, cpBodyVelocityFunc velocityFunc);
fn C.cpBodySetVelocityUpdateFunc(body &C.cpBody, velocityFunc C.cpBodyVelocityFunc)

// set_velocity_update_func sets the callback used to update a body's velocity.
@[inline]
pub fn (mut body Body) set_velocity_update_func(velocityFunc C.cpBodyVelocityFunc) {
	C.cpBodySetVelocityUpdateFunc(body, velocityFunc)
}

// C signature:
// CP_EXPORT void cpBodySetPositionUpdateFunc(cpBody *body, cpBodyPositionFunc positionFunc);
fn C.cpBodySetPositionUpdateFunc(body &C.cpBody, positionFunc C.cpBodyPositionFunc)

// set_position_update_func sets the callback used to update a body's position.
// NOTE: It's not generally recommended to override this unless you call the default position update function.
@[inline]
pub fn (mut body Body) set_position_update_func(positionFunc C.cpBodyPositionFunc) {
	C.cpBodySetPositionUpdateFunc(body, positionFunc)
}

// C signature:
// CP_EXPORT void cpBodyUpdateVelocity(cpBody *body, cpVect gravity, cpFloat damping, cpFloat dt);
fn C.cpBodyUpdateVelocity(body &C.cpBody, gravity C.cpVect, damping Float, dt Float)

// update_velocity defaults velocity integration function..
@[inline]
pub fn (mut body Body) update_velocity(gravity Vect, damping Float, dt Float) {
	C.cpBodyUpdateVelocity(body, gravity, damping, dt)
}

// C signature:
// CP_EXPORT void cpBodyUpdatePosition(cpBody *body, cpFloat dt);
fn C.cpBodyUpdatePosition(body &C.cpBody, dt Float)

// update_position defaults position integration function.
@[inline]
pub fn (mut body Body) update_position(dt Float) {
	C.cpBodyUpdatePosition(body, dt)
}

// C signature:
// CP_EXPORT cpVect cpBodyLocalToWorld(const cpBody *body, const cpVect point);
fn C.cpBodyLocalToWorld(body &C.cpBody, point C.cpVect) C.cpVect

// local_to_world converts body relative/local coordinates to absolute/world coordinates.
@[inline]
pub fn (mut body Body) local_to_world(point Vect) Vect {
	return C.cpBodyLocalToWorld(body, point)
}

// C signature:
// CP_EXPORT cpVect cpBodyWorldToLocal(const cpBody *body, const cpVect point);
fn C.cpBodyWorldToLocal(body &C.cpBody, point C.cpVect) C.cpVect

// world_to_local converts body absolute/world coordinates to  relative/local coordinates.
@[inline]
pub fn (mut body Body) world_to_local(point Vect) Vect {
	return C.cpBodyWorldToLocal(body, point)
}

// C signature:
// CP_EXPORT void cpBodyApplyForceAtWorldPoint(cpBody *body, cpVect force, cpVect point);
fn C.cpBodyApplyForceAtWorldPoint(body &C.cpBody, force C.cpVect, point C.cpVect)

// apply_force_at_world_point applys a force to a body. Both the force and point are expressed in world coordinates.
@[inline]
pub fn (mut body Body) apply_force_at_world_point(force Vect, point Vect) {
	C.cpBodyApplyForceAtWorldPoint(body, force, point)
}

// C signature:
// CP_EXPORT void cpBodyApplyForceAtLocalPoint(cpBody *body, cpVect force, cpVect point);
fn C.cpBodyApplyForceAtLocalPoint(body &C.cpBody, force C.cpVect, point C.cpVect)

// apply_force_at_local_point applys a force to a body. Both the force and point are expressed in body local coordinates.
@[inline]
pub fn (mut body Body) apply_force_at_local_point(force Vect, point Vect) {
	C.cpBodyApplyForceAtLocalPoint(body, force, point)
}

// C signature:
// CP_EXPORT void cpBodyApplyImpulseAtWorldPoint(cpBody *body, cpVect impulse, cpVect point);
fn C.cpBodyApplyImpulseAtWorldPoint(body &C.cpBody, impulse C.cpVect, point C.cpVect)

// apply_impulse_at_world_point applys an impulse to a body. Both the impulse and point are expressed in world coordinates.
@[inline]
pub fn (mut body Body) apply_impulse_at_world_point(impulse Vect, point Vect) {
	C.cpBodyApplyImpulseAtWorldPoint(body, impulse, point)
}

// C signature:
// CP_EXPORT void cpBodyApplyImpulseAtLocalPoint(cpBody *body, cpVect impulse, cpVect point);
fn C.cpBodyApplyImpulseAtLocalPoint(body &C.cpBody, impulse C.cpVect, point C.cpVect)

// apply_impulse_at_local_point applys an impulse to a body. Both the impulse and point are expressed in body local coordinates.
@[inline]
pub fn (mut body Body) apply_impulse_at_local_point(impulse Vect, point Vect) {
	C.cpBodyApplyImpulseAtLocalPoint(body, impulse, point)
}

// C signature:
// CP_EXPORT cpVect cpBodyGetVelocityAtWorldPoint(const cpBody *body, cpVect point);
fn C.cpBodyGetVelocityAtWorldPoint(body &C.cpBody, point C.cpVect) C.cpVect

// get_velocity_at_world_point gets the velocity on a body (in world units) at a point on the body in world coordinates.
@[inline]
pub fn (mut body Body) get_velocity_at_world_point(point Vect) Vect {
	return C.cpBodyGetVelocityAtWorldPoint(body, point)
}

// C signature:
// CP_EXPORT cpVect cpBodyGetVelocityAtLocalPoint(const cpBody *body, cpVect point);
fn C.cpBodyGetVelocityAtLocalPoint(body &C.cpBody, point C.cpVect) C.cpVect

// get_velocity_at_local_point gets the velocity on a body (in world units) at a point on the body in local coordinates.
@[inline]
pub fn (mut body Body) get_velocity_at_local_point(point Vect) Vect {
	return C.cpBodyGetVelocityAtLocalPoint(body, point)
}

// C signature:
// CP_EXPORT cpFloat cpBodyKineticEnergy(const cpBody *body);
fn C.cpBodyKineticEnergy(body &C.cpBody) Float

// kinetic_energy gets the amount of kinetic energy contained by the body.
@[inline]
pub fn (mut body Body) kinetic_energy() Float {
	return C.cpBodyKineticEnergy(body)
}

// C signature:
// CP_EXPORT void cpBodyEachShape(cpBody *body, cpBodyShapeIteratorFunc func, void *data);
fn C.cpBodyEachShape(body &C.cpBody, func C.cpBodyShapeIteratorFunc, data voidptr)

// each_shape calls @c func once for each shape attached to @c body and added to the space.
@[inline]
pub fn (mut body Body) each_shape(func C.cpBodyShapeIteratorFunc, data &C.void) {
	C.cpBodyEachShape(body, func, data)
}

// C signature:
// CP_EXPORT void cpBodyEachConstraint(cpBody *body, cpBodyConstraintIteratorFunc func, void *data);
fn C.cpBodyEachConstraint(body &C.cpBody, func C.cpBodyConstraintIteratorFunc, data voidptr)

// each_constraint calls @c func once for each constraint attached to @c body and added to the space.
@[inline]
pub fn (mut body Body) each_constraint(func C.cpBodyConstraintIteratorFunc, data &C.void) {
	C.cpBodyEachConstraint(body, func, data)
}

// C signature:
// CP_EXPORT void cpBodyEachArbiter(cpBody *body, cpBodyArbiterIteratorFunc func, void *data);
fn C.cpBodyEachArbiter(body &C.cpBody, func C.cpBodyArbiterIteratorFunc, data voidptr)

// each_arbiter calls @c func once for each arbiter that is currently active on the body.
@[inline]
pub fn (mut body Body) each_arbiter(func C.cpBodyArbiterIteratorFunc, data &C.void) {
	C.cpBodyEachArbiter(body, func, data)
}

//
// cpConstraint.h
//

// C signature:
// CP_EXPORT void cpConstraintDestroy(cpConstraint *constraint);
fn C.cpConstraintDestroy(constraint &C.cpConstraint)

// destroy destroys a constraint.
@[inline]
pub fn (mut constraint Constraint) destroy() {
	C.cpConstraintDestroy(constraint)
}

// C signature:
// CP_EXPORT void cpConstraintFree(cpConstraint *constraint);
fn C.cpConstraintFree(constraint &C.cpConstraint)

// free destroys and free a constraint.
@[inline]
pub fn (mut constraint Constraint) free() {
	C.cpConstraintFree(constraint)
}

// C signature:
// CP_EXPORT cpSpace* cpConstraintGetSpace(const cpConstraint *constraint);
fn C.cpConstraintGetSpace(constraint &C.cpConstraint) &C.cpSpace

// get_space gets the cpSpace this constraint is added to.
@[inline]
pub fn (mut constraint Constraint) get_space() &Space {
	return C.cpConstraintGetSpace(constraint)
}

// C signature:
// CP_EXPORT cpBody* cpConstraintGetBodyA(const cpConstraint *constraint);
fn C.cpConstraintGetBodyA(constraint &C.cpConstraint) &C.cpBody

// get_body_a gets the first body the constraint is attached to.
@[inline]
pub fn (mut constraint Constraint) get_body_a() &Body {
	return C.cpConstraintGetBodyA(constraint)
}

// C signature:
// CP_EXPORT cpBody* cpConstraintGetBodyB(const cpConstraint *constraint);
fn C.cpConstraintGetBodyB(constraint &C.cpConstraint) &C.cpBody

// get_body_b gets the second body the constraint is attached to.
@[inline]
pub fn (mut constraint Constraint) get_body_b() &Body {
	return C.cpConstraintGetBodyB(constraint)
}

// C signature:
// CP_EXPORT cpFloat cpConstraintGetMaxForce(const cpConstraint *constraint);
fn C.cpConstraintGetMaxForce(constraint &C.cpConstraint) Float

// get_max_force gets the maximum force that this constraint is allowed to use.
@[inline]
pub fn (mut constraint Constraint) get_max_force() Float {
	return C.cpConstraintGetMaxForce(constraint)
}

// C signature:
// CP_EXPORT void cpConstraintSetMaxForce(cpConstraint *constraint, cpFloat maxForce);
fn C.cpConstraintSetMaxForce(constraint &C.cpConstraint, maxForce Float)

// set_max_force sets the maximum force that this constraint is allowed to use. (defaults to INFINITY)
@[inline]
pub fn (mut constraint Constraint) set_max_force(maxForce Float) {
	C.cpConstraintSetMaxForce(constraint, maxForce)
}

// C signature:
// CP_EXPORT cpFloat cpConstraintGetErrorBias(const cpConstraint *constraint);
fn C.cpConstraintGetErrorBias(constraint &C.cpConstraint) Float

// get_error_bias gets rate at which joint error is corrected.
@[inline]
pub fn (mut constraint Constraint) get_error_bias() Float {
	return C.cpConstraintGetErrorBias(constraint)
}

// C signature:
// CP_EXPORT void cpConstraintSetErrorBias(cpConstraint *constraint, cpFloat errorBias);
fn C.cpConstraintSetErrorBias(constraint &C.cpConstraint, errorBias Float)

// set_error_bias sets rate at which joint error is corrected.
// Defaults to pow(1.0 - 0.1, 60.0) meaning that it will
// correct 10% of the error every 1/60th of a second.
@[inline]
pub fn (mut constraint Constraint) set_error_bias(errorBias Float) {
	C.cpConstraintSetErrorBias(constraint, errorBias)
}

// C signature:
// CP_EXPORT cpFloat cpConstraintGetMaxBias(const cpConstraint *constraint);
fn C.cpConstraintGetMaxBias(constraint &C.cpConstraint) Float

// get_max_bias gets the maximum rate at which joint error is corrected.
@[inline]
pub fn (mut constraint Constraint) get_max_bias() Float {
	return C.cpConstraintGetMaxBias(constraint)
}

// C signature:
// CP_EXPORT void cpConstraintSetMaxBias(cpConstraint *constraint, cpFloat maxBias);
fn C.cpConstraintSetMaxBias(constraint &C.cpConstraint, maxBias Float)

// set_max_bias sets the maximum rate at which joint error is corrected. (defaults to INFINITY)
@[inline]
pub fn (mut constraint Constraint) set_max_bias(maxBias Float) {
	C.cpConstraintSetMaxBias(constraint, maxBias)
}

// C signature:
// CP_EXPORT cpBool cpConstraintGetCollideBodies(const cpConstraint *constraint);
fn C.cpConstraintGetCollideBodies(constraint &C.cpConstraint) bool

// get_collide_bodies gets if the two bodies connected by the constraint are allowed to collide or not.
@[inline]
pub fn (mut constraint Constraint) get_collide_bodies() bool {
	return C.cpConstraintGetCollideBodies(constraint)
}

// C signature:
// CP_EXPORT void cpConstraintSetCollideBodies(cpConstraint *constraint, cpBool collideBodies);
fn C.cpConstraintSetCollideBodies(constraint &C.cpConstraint, collideBodies bool)

// set_collide_bodies sets if the two bodies connected by the constraint are allowed to collide or not. (defaults to cpFalse)
@[inline]
pub fn (mut constraint Constraint) set_collide_bodies(collideBodies bool) {
	C.cpConstraintSetCollideBodies(constraint, collideBodies)
}

// C signature:
// CP_EXPORT cpConstraintPreSolveFunc cpConstraintGetPreSolveFunc(const cpConstraint *constraint);
fn C.cpConstraintGetPreSolveFunc(constraint &C.cpConstraint) C.cpConstraintPreSolveFunc

// get_pre_solve_func gets the pre-solve function that is called before the solver runs.
@[inline]
pub fn (mut constraint Constraint) get_pre_solve_func() C.cpConstraintPreSolveFunc {
	return C.cpConstraintGetPreSolveFunc(constraint)
}

// C signature:
// CP_EXPORT void cpConstraintSetPreSolveFunc(cpConstraint *constraint, cpConstraintPreSolveFunc preSolveFunc);
fn C.cpConstraintSetPreSolveFunc(constraint &C.cpConstraint, preSolveFunc C.cpConstraintPreSolveFunc)

// set_pre_solve_func sets the pre-solve function that is called before the solver runs.
@[inline]
pub fn (mut constraint Constraint) set_pre_solve_func(preSolveFunc C.cpConstraintPreSolveFunc) {
	C.cpConstraintSetPreSolveFunc(constraint, preSolveFunc)
}

// C signature:
// CP_EXPORT cpConstraintPostSolveFunc cpConstraintGetPostSolveFunc(const cpConstraint *constraint);
fn C.cpConstraintGetPostSolveFunc(constraint &C.cpConstraint) C.cpConstraintPostSolveFunc

// get_post_solve_func gets the post-solve function that is called before the solver runs.
@[inline]
pub fn (mut constraint Constraint) get_post_solve_func() C.cpConstraintPostSolveFunc {
	return C.cpConstraintGetPostSolveFunc(constraint)
}

// C signature:
// CP_EXPORT void cpConstraintSetPostSolveFunc(cpConstraint *constraint, cpConstraintPostSolveFunc postSolveFunc);
fn C.cpConstraintSetPostSolveFunc(constraint &C.cpConstraint, postSolveFunc C.cpConstraintPostSolveFunc)

// set_post_solve_func sets the post-solve function that is called before the solver runs.
@[inline]
pub fn (mut constraint Constraint) set_post_solve_func(postSolveFunc C.cpConstraintPostSolveFunc) {
	C.cpConstraintSetPostSolveFunc(constraint, postSolveFunc)
}

// C signature:
// CP_EXPORT cpDataPointer cpConstraintGetUserData(const cpConstraint *constraint);
fn C.cpConstraintGetUserData(constraint &C.cpConstraint) C.cpDataPointer

// get_user_data gets the user definable data pointer for this constraint
@[inline]
pub fn (mut constraint Constraint) get_user_data() C.cpDataPointer {
	return C.cpConstraintGetUserData(constraint)
}

// C signature:
// CP_EXPORT void cpConstraintSetUserData(cpConstraint *constraint, cpDataPointer userData);
fn C.cpConstraintSetUserData(constraint &C.cpConstraint, userData C.cpDataPointer)

// set_user_data sets the user definable data pointer for this constraint
@[inline]
pub fn (mut constraint Constraint) set_user_data(userData C.cpDataPointer) {
	C.cpConstraintSetUserData(constraint, userData)
}

// C signature:
// CP_EXPORT cpFloat cpConstraintGetImpulse(cpConstraint *constraint);
fn C.cpConstraintGetImpulse(constraint &C.cpConstraint) Float

// get_impulse gets the last impulse applied by this constraint.
@[inline]
pub fn (mut constraint Constraint) get_impulse() Float {
	return C.cpConstraintGetImpulse(constraint)
}

//
// cpDampedRotarySpring.h
//

// C signature:
// CP_EXPORT cpBool cpConstraintIsDampedRotarySpring(const cpConstraint *constraint);
fn C.cpConstraintIsDampedRotarySpring(constraint &C.cpConstraint) bool

// is_damped_rotary_spring checks if a constraint is a damped rotary springs.
@[inline]
pub fn (mut constraint Constraint) is_damped_rotary_spring() bool {
	return C.cpConstraintIsDampedRotarySpring(constraint)
}

// C signature:
// CP_EXPORT cpDampedRotarySpring* cpDampedRotarySpringAlloc();
fn C.cpDampedRotarySpringAlloc() &C.cpDampedRotarySpring

// damped_rotary_spring_alloc allocates a damped rotary spring.
@[inline]
pub fn damped_rotary_spring_alloc() &DampedRotarySpring {
	return C.cpDampedRotarySpringAlloc()
}

// C signature:
// CP_EXPORT cpDampedRotarySpring* cpDampedRotarySpringInit(cpDampedRotarySpring *joint, cpBody *a, cpBody *b, cpFloat restAngle, cpFloat stiffness, cpFloat damping);
fn C.cpDampedRotarySpringInit(joint &C.cpDampedRotarySpring, a &C.cpBody, b &C.cpBody, restAngle Float, stiffness Float, damping Float) &C.cpDampedRotarySpring

// init initializes a damped rotary spring.
@[inline]
pub fn (mut joint DampedRotarySpring) init(a &Body, b &Body, restAngle Float, stiffness Float, damping Float) &DampedRotarySpring {
	return C.cpDampedRotarySpringInit(joint, a, b, restAngle, stiffness, damping)
}

// C signature:
// CP_EXPORT cpConstraint* cpDampedRotarySpringNew(cpBody *a, cpBody *b, cpFloat restAngle, cpFloat stiffness, cpFloat damping);
fn C.cpDampedRotarySpringNew(a &C.cpBody, b &C.cpBody, restAngle Float, stiffness Float, damping Float) &C.cpConstraint

// damped_rotary_spring_new allocates and initialize a damped rotary spring.
@[inline]
pub fn damped_rotary_spring_new(a &Body, b &Body, restAngle Float, stiffness Float, damping Float) &Constraint {
	return C.cpDampedRotarySpringNew(a, b, restAngle, stiffness, damping)
}

// C signature:
// CP_EXPORT cpFloat cpDampedRotarySpringGetRestAngle(const cpConstraint *constraint);
fn C.cpDampedRotarySpringGetRestAngle(constraint &C.cpConstraint) Float

// damped_rotary_spring_get_rest_angle gets the rest length of the spring.
@[inline]
pub fn damped_rotary_spring_get_rest_angle(constraint &Constraint) Float {
	return C.cpDampedRotarySpringGetRestAngle(constraint)
}

// C signature:
// CP_EXPORT void cpDampedRotarySpringSetRestAngle(cpConstraint *constraint, cpFloat restAngle);
fn C.cpDampedRotarySpringSetRestAngle(constraint &C.cpConstraint, restAngle Float)

// damped_rotary_spring_set_rest_angle sets the rest length of the spring.
@[inline]
pub fn damped_rotary_spring_set_rest_angle(constraint &Constraint, restAngle Float) {
	C.cpDampedRotarySpringSetRestAngle(constraint, restAngle)
}

// C signature:
// CP_EXPORT cpFloat cpDampedRotarySpringGetStiffness(const cpConstraint *constraint);
fn C.cpDampedRotarySpringGetStiffness(constraint &C.cpConstraint) Float

// damped_rotary_spring_get_stiffness gets the stiffness of the spring in force/distance.
@[inline]
pub fn damped_rotary_spring_get_stiffness(constraint &Constraint) Float {
	return C.cpDampedRotarySpringGetStiffness(constraint)
}

// C signature:
// CP_EXPORT void cpDampedRotarySpringSetStiffness(cpConstraint *constraint, cpFloat stiffness);
fn C.cpDampedRotarySpringSetStiffness(constraint &C.cpConstraint, stiffness Float)

// damped_rotary_spring_set_stiffness sets the stiffness of the spring in force/distance.
@[inline]
pub fn damped_rotary_spring_set_stiffness(constraint &Constraint, stiffness Float) {
	C.cpDampedRotarySpringSetStiffness(constraint, stiffness)
}

// C signature:
// CP_EXPORT cpFloat cpDampedRotarySpringGetDamping(const cpConstraint *constraint);
fn C.cpDampedRotarySpringGetDamping(constraint &C.cpConstraint) Float

// damped_rotary_spring_get_damping gets the damping of the spring.
@[inline]
pub fn damped_rotary_spring_get_damping(constraint &Constraint) Float {
	return C.cpDampedRotarySpringGetDamping(constraint)
}

// C signature:
// CP_EXPORT void cpDampedRotarySpringSetDamping(cpConstraint *constraint, cpFloat damping);
fn C.cpDampedRotarySpringSetDamping(constraint &C.cpConstraint, damping Float)

// damped_rotary_spring_set_damping sets the damping of the spring.
@[inline]
pub fn damped_rotary_spring_set_damping(constraint &Constraint, damping Float) {
	C.cpDampedRotarySpringSetDamping(constraint, damping)
}

// C signature:
// CP_EXPORT cpDampedRotarySpringTorqueFunc cpDampedRotarySpringGetSpringTorqueFunc(const cpConstraint *constraint);
fn C.cpDampedRotarySpringGetSpringTorqueFunc(constraint &C.cpConstraint) C.cpDampedRotarySpringTorqueFunc

// damped_rotary_spring_get_spring_torque_func gets the damping of the spring.
@[inline]
pub fn damped_rotary_spring_get_spring_torque_func(constraint &Constraint) C.cpDampedRotarySpringTorqueFunc {
	return C.cpDampedRotarySpringGetSpringTorqueFunc(constraint)
}

// C signature:
// CP_EXPORT void cpDampedRotarySpringSetSpringTorqueFunc(cpConstraint *constraint, cpDampedRotarySpringTorqueFunc springTorqueFunc);
fn C.cpDampedRotarySpringSetSpringTorqueFunc(constraint &C.cpConstraint, springTorqueFunc C.cpDampedRotarySpringTorqueFunc)

// damped_rotary_spring_set_spring_torque_func sets the damping of the spring.
@[inline]
pub fn damped_rotary_spring_set_spring_torque_func(constraint &Constraint, springTorqueFunc C.cpDampedRotarySpringTorqueFunc) {
	C.cpDampedRotarySpringSetSpringTorqueFunc(constraint, springTorqueFunc)
}

//
// cpDampedSpring.h
//

// C signature:
// CP_EXPORT cpBool cpConstraintIsDampedSpring(const cpConstraint *constraint);
fn C.cpConstraintIsDampedSpring(constraint &C.cpConstraint) bool

// is_damped_spring checks if a constraint is a slide joint.
@[inline]
pub fn (mut constraint Constraint) is_damped_spring() bool {
	return C.cpConstraintIsDampedSpring(constraint)
}

// C signature:
// CP_EXPORT cpDampedSpring* cpDampedSpringAlloc();
fn C.cpDampedSpringAlloc() &C.cpDampedSpring

// damped_spring_alloc allocates a damped spring.
@[inline]
pub fn damped_spring_alloc() &DampedSpring {
	return C.cpDampedSpringAlloc()
}

// C signature:
// CP_EXPORT cpDampedSpring* cpDampedSpringInit(cpDampedSpring *joint, cpBody *a, cpBody *b, cpVect anchorA, cpVect anchorB, cpFloat restLength, cpFloat stiffness, cpFloat damping);
fn C.cpDampedSpringInit(joint &C.cpDampedSpring, a &C.cpBody, b &C.cpBody, anchorA C.cpVect, anchorB C.cpVect, restLength Float, stiffness Float, damping Float) &C.cpDampedSpring

// init initializes a damped spring.
@[inline]
pub fn (mut joint DampedSpring) init(a &Body, b &Body, anchorA Vect, anchorB Vect, restLength Float, stiffness Float, damping Float) &DampedSpring {
	return C.cpDampedSpringInit(joint, a, b, anchorA, anchorB, restLength, stiffness,
		damping)
}

// C signature:
// CP_EXPORT cpConstraint* cpDampedSpringNew(cpBody *a, cpBody *b, cpVect anchorA, cpVect anchorB, cpFloat restLength, cpFloat stiffness, cpFloat damping);
fn C.cpDampedSpringNew(a &C.cpBody, b &C.cpBody, anchorA C.cpVect, anchorB C.cpVect, restLength Float, stiffness Float, damping Float) &C.cpConstraint

// damped_spring_new allocates and initialize a damped spring.
@[inline]
pub fn damped_spring_new(a &Body, b &Body, anchorA Vect, anchorB Vect, restLength Float, stiffness Float, damping Float) &Constraint {
	return C.cpDampedSpringNew(a, b, anchorA, anchorB, restLength, stiffness, damping)
}

// C signature:
// CP_EXPORT cpVect cpDampedSpringGetAnchorA(const cpConstraint *constraint);
fn C.cpDampedSpringGetAnchorA(constraint &C.cpConstraint) C.cpVect

// damped_spring_get_anchor_a gets the location of the first anchor relative to the first body.
@[inline]
pub fn damped_spring_get_anchor_a(constraint &Constraint) Vect {
	return C.cpDampedSpringGetAnchorA(constraint)
}

// C signature:
// CP_EXPORT void cpDampedSpringSetAnchorA(cpConstraint *constraint, cpVect anchorA);
fn C.cpDampedSpringSetAnchorA(constraint &C.cpConstraint, anchorA C.cpVect)

// damped_spring_set_anchor_a sets the location of the first anchor relative to the first body.
@[inline]
pub fn damped_spring_set_anchor_a(constraint &Constraint, anchorA Vect) {
	C.cpDampedSpringSetAnchorA(constraint, anchorA)
}

// C signature:
// CP_EXPORT cpVect cpDampedSpringGetAnchorB(const cpConstraint *constraint);
fn C.cpDampedSpringGetAnchorB(constraint &C.cpConstraint) C.cpVect

// damped_spring_get_anchor_b gets the location of the second anchor relative to the second body.
@[inline]
pub fn damped_spring_get_anchor_b(constraint &Constraint) Vect {
	return C.cpDampedSpringGetAnchorB(constraint)
}

// C signature:
// CP_EXPORT void cpDampedSpringSetAnchorB(cpConstraint *constraint, cpVect anchorB);
fn C.cpDampedSpringSetAnchorB(constraint &C.cpConstraint, anchorB C.cpVect)

// damped_spring_set_anchor_b sets the location of the second anchor relative to the second body.
@[inline]
pub fn damped_spring_set_anchor_b(constraint &Constraint, anchorB Vect) {
	C.cpDampedSpringSetAnchorB(constraint, anchorB)
}

// C signature:
// CP_EXPORT cpFloat cpDampedSpringGetRestLength(const cpConstraint *constraint);
fn C.cpDampedSpringGetRestLength(constraint &C.cpConstraint) Float

// damped_spring_get_rest_length gets the rest length of the spring.
@[inline]
pub fn damped_spring_get_rest_length(constraint &Constraint) Float {
	return C.cpDampedSpringGetRestLength(constraint)
}

// C signature:
// CP_EXPORT void cpDampedSpringSetRestLength(cpConstraint *constraint, cpFloat restLength);
fn C.cpDampedSpringSetRestLength(constraint &C.cpConstraint, restLength Float)

// damped_spring_set_rest_length sets the rest length of the spring.
@[inline]
pub fn damped_spring_set_rest_length(constraint &Constraint, restLength Float) {
	C.cpDampedSpringSetRestLength(constraint, restLength)
}

// C signature:
// CP_EXPORT cpFloat cpDampedSpringGetStiffness(const cpConstraint *constraint);
fn C.cpDampedSpringGetStiffness(constraint &C.cpConstraint) Float

// damped_spring_get_stiffness gets the stiffness of the spring in force/distance.
@[inline]
pub fn damped_spring_get_stiffness(constraint &Constraint) Float {
	return C.cpDampedSpringGetStiffness(constraint)
}

// C signature:
// CP_EXPORT void cpDampedSpringSetStiffness(cpConstraint *constraint, cpFloat stiffness);
fn C.cpDampedSpringSetStiffness(constraint &C.cpConstraint, stiffness Float)

// damped_spring_set_stiffness sets the stiffness of the spring in force/distance.
@[inline]
pub fn damped_spring_set_stiffness(constraint &Constraint, stiffness Float) {
	C.cpDampedSpringSetStiffness(constraint, stiffness)
}

// C signature:
// CP_EXPORT cpFloat cpDampedSpringGetDamping(const cpConstraint *constraint);
fn C.cpDampedSpringGetDamping(constraint &C.cpConstraint) Float

// damped_spring_get_damping gets the damping of the spring.
@[inline]
pub fn damped_spring_get_damping(constraint &Constraint) Float {
	return C.cpDampedSpringGetDamping(constraint)
}

// C signature:
// CP_EXPORT void cpDampedSpringSetDamping(cpConstraint *constraint, cpFloat damping);
fn C.cpDampedSpringSetDamping(constraint &C.cpConstraint, damping Float)

// damped_spring_set_damping sets the damping of the spring.
@[inline]
pub fn damped_spring_set_damping(constraint &Constraint, damping Float) {
	C.cpDampedSpringSetDamping(constraint, damping)
}

// C signature:
// CP_EXPORT cpDampedSpringForceFunc cpDampedSpringGetSpringForceFunc(const cpConstraint *constraint);
fn C.cpDampedSpringGetSpringForceFunc(constraint &C.cpConstraint) C.cpDampedSpringForceFunc

// damped_spring_get_spring_force_func gets the damping of the spring.
@[inline]
pub fn damped_spring_get_spring_force_func(constraint &Constraint) C.cpDampedSpringForceFunc {
	return C.cpDampedSpringGetSpringForceFunc(constraint)
}

// C signature:
// CP_EXPORT void cpDampedSpringSetSpringForceFunc(cpConstraint *constraint, cpDampedSpringForceFunc springForceFunc);
fn C.cpDampedSpringSetSpringForceFunc(constraint &C.cpConstraint, springForceFunc C.cpDampedSpringForceFunc)

// damped_spring_set_spring_force_func sets the damping of the spring.
@[inline]
pub fn damped_spring_set_spring_force_func(constraint &Constraint, springForceFunc C.cpDampedSpringForceFunc) {
	C.cpDampedSpringSetSpringForceFunc(constraint, springForceFunc)
}

//
// cpGearJoint.h
//

// C signature:
// CP_EXPORT cpBool cpConstraintIsGearJoint(const cpConstraint *constraint);
fn C.cpConstraintIsGearJoint(constraint &C.cpConstraint) bool

// is_gear_joint checks if a constraint is a damped rotary springs.
@[inline]
pub fn (mut constraint Constraint) is_gear_joint() bool {
	return C.cpConstraintIsGearJoint(constraint)
}

// C signature:
// CP_EXPORT cpGearJoint* cpGearJointAlloc();
fn C.cpGearJointAlloc() &C.cpGearJoint

// gear_joint_alloc allocates a gear joint.
@[inline]
pub fn gear_joint_alloc() &GearJoint {
	return C.cpGearJointAlloc()
}

// C signature:
// CP_EXPORT cpGearJoint* cpGearJointInit(cpGearJoint *joint, cpBody *a, cpBody *b, cpFloat phase, cpFloat ratio);
fn C.cpGearJointInit(joint &C.cpGearJoint, a &C.cpBody, b &C.cpBody, phase Float, ratio Float) &C.cpGearJoint

// init initializes a gear joint.
@[inline]
pub fn (mut joint GearJoint) init(a &Body, b &Body, phase Float, ratio Float) &GearJoint {
	return C.cpGearJointInit(joint, a, b, phase, ratio)
}

// C signature:
// CP_EXPORT cpConstraint* cpGearJointNew(cpBody *a, cpBody *b, cpFloat phase, cpFloat ratio);
fn C.cpGearJointNew(a &C.cpBody, b &C.cpBody, phase Float, ratio Float) &C.cpConstraint

// gear_joint_new allocates and initialize a gear joint.
@[inline]
pub fn gear_joint_new(a &Body, b &Body, phase Float, ratio Float) &Constraint {
	return C.cpGearJointNew(a, b, phase, ratio)
}

// C signature:
// CP_EXPORT cpFloat cpGearJointGetPhase(const cpConstraint *constraint);
fn C.cpGearJointGetPhase(constraint &C.cpConstraint) Float

// gear_joint_get_phase gets the phase offset of the gears.
@[inline]
pub fn gear_joint_get_phase(constraint &Constraint) Float {
	return C.cpGearJointGetPhase(constraint)
}

// C signature:
// CP_EXPORT void cpGearJointSetPhase(cpConstraint *constraint, cpFloat phase);
fn C.cpGearJointSetPhase(constraint &C.cpConstraint, phase Float)

// gear_joint_set_phase sets the phase offset of the gears.
@[inline]
pub fn gear_joint_set_phase(constraint &Constraint, phase Float) {
	C.cpGearJointSetPhase(constraint, phase)
}

// C signature:
// CP_EXPORT cpFloat cpGearJointGetRatio(const cpConstraint *constraint);
fn C.cpGearJointGetRatio(constraint &C.cpConstraint) Float

// gear_joint_get_ratio gets the angular distance of each ratchet.
@[inline]
pub fn gear_joint_get_ratio(constraint &Constraint) Float {
	return C.cpGearJointGetRatio(constraint)
}

// C signature:
// CP_EXPORT void cpGearJointSetRatio(cpConstraint *constraint, cpFloat ratio);
fn C.cpGearJointSetRatio(constraint &C.cpConstraint, ratio Float)

// gear_joint_set_ratio sets the ratio of a gear joint.
@[inline]
pub fn gear_joint_set_ratio(constraint &Constraint, ratio Float) {
	C.cpGearJointSetRatio(constraint, ratio)
}

//
// cpGrooveJoint.h
//

// C signature:
// CP_EXPORT cpBool cpConstraintIsGrooveJoint(const cpConstraint *constraint);
fn C.cpConstraintIsGrooveJoint(constraint &C.cpConstraint) bool

// is_groove_joint checks if a constraint is a slide joint.
@[inline]
pub fn (mut constraint Constraint) is_groove_joint() bool {
	return C.cpConstraintIsGrooveJoint(constraint)
}

// C signature:
// CP_EXPORT cpGrooveJoint* cpGrooveJointAlloc();
fn C.cpGrooveJointAlloc() &C.cpGrooveJoint

// groove_joint_alloc allocates a groove joint.
@[inline]
pub fn groove_joint_alloc() &GrooveJoint {
	return C.cpGrooveJointAlloc()
}

// C signature:
// CP_EXPORT cpGrooveJoint* cpGrooveJointInit(cpGrooveJoint *joint, cpBody *a, cpBody *b, cpVect groove_a, cpVect groove_b, cpVect anchorB);
fn C.cpGrooveJointInit(joint &C.cpGrooveJoint, a &C.cpBody, b &C.cpBody, groove_a C.cpVect, groove_b C.cpVect, anchorB C.cpVect) &C.cpGrooveJoint

// init initializes a groove joint.
@[inline]
pub fn (mut joint GrooveJoint) init(a &Body, b &Body, groove_a Vect, groove_b Vect, anchorB Vect) &GrooveJoint {
	return C.cpGrooveJointInit(joint, a, b, groove_a, groove_b, anchorB)
}

// C signature:
// CP_EXPORT cpConstraint* cpGrooveJointNew(cpBody *a, cpBody *b, cpVect groove_a, cpVect groove_b, cpVect anchorB);
fn C.cpGrooveJointNew(a &C.cpBody, b &C.cpBody, groove_a C.cpVect, groove_b C.cpVect, anchorB C.cpVect) &C.cpConstraint

// groove_joint_new allocates and initialize a groove joint.
@[inline]
pub fn groove_joint_new(a &Body, b &Body, groove_a Vect, groove_b Vect, anchorB Vect) &Constraint {
	return C.cpGrooveJointNew(a, b, groove_a, groove_b, anchorB)
}

// C signature:
// CP_EXPORT cpVect cpGrooveJointGetGrooveA(const cpConstraint *constraint);
fn C.cpGrooveJointGetGrooveA(constraint &C.cpConstraint) C.cpVect

// groove_joint_get_groove_a gets the first endpoint of the groove relative to the first body.
@[inline]
pub fn groove_joint_get_groove_a(constraint &Constraint) Vect {
	return C.cpGrooveJointGetGrooveA(constraint)
}

// C signature:
// CP_EXPORT void cpGrooveJointSetGrooveA(cpConstraint *constraint, cpVect grooveA);
fn C.cpGrooveJointSetGrooveA(constraint &C.cpConstraint, grooveA C.cpVect)

// groove_joint_set_groove_a sets the first endpoint of the groove relative to the first body.
@[inline]
pub fn groove_joint_set_groove_a(constraint &Constraint, grooveA Vect) {
	C.cpGrooveJointSetGrooveA(constraint, grooveA)
}

// C signature:
// CP_EXPORT cpVect cpGrooveJointGetGrooveB(const cpConstraint *constraint);
fn C.cpGrooveJointGetGrooveB(constraint &C.cpConstraint) C.cpVect

// groove_joint_get_groove_b gets the first endpoint of the groove relative to the first body.
@[inline]
pub fn groove_joint_get_groove_b(constraint &Constraint) Vect {
	return C.cpGrooveJointGetGrooveB(constraint)
}

// C signature:
// CP_EXPORT void cpGrooveJointSetGrooveB(cpConstraint *constraint, cpVect grooveB);
fn C.cpGrooveJointSetGrooveB(constraint &C.cpConstraint, grooveB C.cpVect)

// groove_joint_set_groove_b sets the first endpoint of the groove relative to the first body.
@[inline]
pub fn groove_joint_set_groove_b(constraint &Constraint, grooveB Vect) {
	C.cpGrooveJointSetGrooveB(constraint, grooveB)
}

// C signature:
// CP_EXPORT cpVect cpGrooveJointGetAnchorB(const cpConstraint *constraint);
fn C.cpGrooveJointGetAnchorB(constraint &C.cpConstraint) C.cpVect

// groove_joint_get_anchor_b gets the location of the second anchor relative to the second body.
@[inline]
pub fn groove_joint_get_anchor_b(constraint &Constraint) Vect {
	return C.cpGrooveJointGetAnchorB(constraint)
}

// C signature:
// CP_EXPORT void cpGrooveJointSetAnchorB(cpConstraint *constraint, cpVect anchorB);
fn C.cpGrooveJointSetAnchorB(constraint &C.cpConstraint, anchorB C.cpVect)

// groove_joint_set_anchor_b sets the location of the second anchor relative to the second body.
@[inline]
pub fn groove_joint_set_anchor_b(constraint &Constraint, anchorB Vect) {
	C.cpGrooveJointSetAnchorB(constraint, anchorB)
}

//
// cpHastySpace.h
//

@[typedef]
struct C.cpHastySpace {}

pub type HastySpace = C.cpHastySpace

// C signature:
// CP_EXPORT cpSpace *cpHastySpaceNew();
fn C.cpHastySpaceNew() &C.cpSpace

// hasty_space_new creates a new hasty space.
// On ARM platforms that support NEON, this will enable the vectorized solver.
// cpHastySpace also supports multiple threads, but runs single threaded by default for determinism.
@[inline]
pub fn hasty_space_new() &Space {
	return C.cpHastySpaceNew()
}

// C signature:
// CP_EXPORT void cpHastySpaceFree(cpSpace *space);
fn C.cpHastySpaceFree(space &C.cpSpace)
@[inline]
pub fn hasty_space_free(space &Space) {
	C.cpHastySpaceFree(space)
}

// C signature:
// CP_EXPORT void cpHastySpaceSetThreads(cpSpace *space, unsigned long threads);
fn C.cpHastySpaceSetThreads(space &C.cpSpace, threads u32)

// hasty_space_set_threads sets the number of threads to use for the solver.
// Currently Chipmunk is limited to 2 threads as using more generally provides very minimal performance gains.
// Passing 0 as the thread count on iOS or OS X will cause Chipmunk to automatically detect the number of threads it should use.
// On other platforms passing 0 for the thread count will set 1 thread.
@[inline]
pub fn hasty_space_set_threads(space &Space, threads u32) {
	C.cpHastySpaceSetThreads(space, threads)
}

// C signature:
// CP_EXPORT void cpHastySpaceStep(cpSpace *space, cpFloat dt);
fn C.cpHastySpaceStep(space &C.cpSpace, dt Float)

// hasty_space_step whens stepping a hasty space, you must use this function.
@[inline]
pub fn hasty_space_step(space &Space, dt Float) {
	C.cpHastySpaceStep(space, dt)
}

//
// cpMarch.h
//

// C signature:
// CP_EXPORT void cpMarchSoft(   cpBB bb, unsigned long x_samples, unsigned long y_samples, cpFloat threshold,    cpMarchSegmentFunc segment, void *segment_data,    cpMarchSampleFunc sample, void *sample_data  );
fn C.cpMarchSoft(bb C.cpBB, x_samples u32, y_samples u32, threshold Float, segment C.cpMarchSegmentFunc, segment_data voidptr, sample C.cpMarchSampleFunc, sample_data voidptr)

// march_soft traces an anti-aliased contour of an image along a particular threshold.
// The given number of samples will be taken and spread across the bounding box area using the sampling function and context.
// The segment function will be called for each segment detected that lies along the density contour for @c threshold.
@[inline]
pub fn march_soft(bb BB, x_samples u32, y_samples u32, threshold Float, segment C.cpMarchSegmentFunc, segment_data &C.void, sample C.cpMarchSampleFunc, sample_data &C.void) {
	C.cpMarchSoft(bb, x_samples, y_samples, threshold, segment, segment_data, sample,
		sample_data)
}

// C signature:
// CP_EXPORT void cpMarchHard(   cpBB bb, unsigned long x_samples, unsigned long y_samples, cpFloat threshold,    cpMarchSegmentFunc segment, void *segment_data,    cpMarchSampleFunc sample, void *sample_data  );
fn C.cpMarchHard(bb C.cpBB, x_samples u32, y_samples u32, threshold Float, segment C.cpMarchSegmentFunc, segment_data voidptr, sample C.cpMarchSampleFunc, sample_data voidptr)

// march_hard traces an aliased curve of an image along a particular threshold.
// The given number of samples will be taken and spread across the bounding box area using the sampling function and context.
// The segment function will be called for each segment detected that lies along the density contour for @c threshold.
@[inline]
pub fn march_hard(bb BB, x_samples u32, y_samples u32, threshold Float, segment C.cpMarchSegmentFunc, segment_data &C.void, sample C.cpMarchSampleFunc, sample_data &C.void) {
	C.cpMarchHard(bb, x_samples, y_samples, threshold, segment, segment_data, sample,
		sample_data)
}

//
// cpPinJoint.h
//

// C signature:
// CP_EXPORT cpBool cpConstraintIsPinJoint(const cpConstraint *constraint);
fn C.cpConstraintIsPinJoint(constraint &C.cpConstraint) bool

// is_pin_joint checks if a constraint is a pin joint.
@[inline]
pub fn (mut constraint Constraint) is_pin_joint() bool {
	return C.cpConstraintIsPinJoint(constraint)
}

// C signature:
// CP_EXPORT cpPinJoint* cpPinJointAlloc();
fn C.cpPinJointAlloc() &C.cpPinJoint

// pin_joint_alloc allocates a pin joint.
@[inline]
pub fn pin_joint_alloc() &PinJoint {
	return C.cpPinJointAlloc()
}

// C signature:
// CP_EXPORT cpPinJoint* cpPinJointInit(cpPinJoint *joint, cpBody *a, cpBody *b, cpVect anchorA, cpVect anchorB);
fn C.cpPinJointInit(joint &C.cpPinJoint, a &C.cpBody, b &C.cpBody, anchorA C.cpVect, anchorB C.cpVect) &C.cpPinJoint

// init initializes a pin joint.
@[inline]
pub fn (mut joint PinJoint) init(a &Body, b &Body, anchorA Vect, anchorB Vect) &PinJoint {
	return C.cpPinJointInit(joint, a, b, anchorA, anchorB)
}

// C signature:
// CP_EXPORT cpConstraint* cpPinJointNew(cpBody *a, cpBody *b, cpVect anchorA, cpVect anchorB);
fn C.cpPinJointNew(a &C.cpBody, b &C.cpBody, anchorA C.cpVect, anchorB C.cpVect) &C.cpConstraint

// pin_joint_new allocates and initialize a pin joint.
@[inline]
pub fn pin_joint_new(a &Body, b &Body, anchorA Vect, anchorB Vect) &Constraint {
	return C.cpPinJointNew(a, b, anchorA, anchorB)
}

// C signature:
// CP_EXPORT cpVect cpPinJointGetAnchorA(const cpConstraint *constraint);
fn C.cpPinJointGetAnchorA(constraint &C.cpConstraint) C.cpVect

// pin_joint_get_anchor_a gets the location of the first anchor relative to the first body.
@[inline]
pub fn pin_joint_get_anchor_a(constraint &Constraint) Vect {
	return C.cpPinJointGetAnchorA(constraint)
}

// C signature:
// CP_EXPORT void cpPinJointSetAnchorA(cpConstraint *constraint, cpVect anchorA);
fn C.cpPinJointSetAnchorA(constraint &C.cpConstraint, anchorA C.cpVect)

// pin_joint_set_anchor_a sets the location of the first anchor relative to the first body.
@[inline]
pub fn pin_joint_set_anchor_a(constraint &Constraint, anchorA Vect) {
	C.cpPinJointSetAnchorA(constraint, anchorA)
}

// C signature:
// CP_EXPORT cpVect cpPinJointGetAnchorB(const cpConstraint *constraint);
fn C.cpPinJointGetAnchorB(constraint &C.cpConstraint) C.cpVect

// pin_joint_get_anchor_b gets the location of the second anchor relative to the second body.
@[inline]
pub fn pin_joint_get_anchor_b(constraint &Constraint) Vect {
	return C.cpPinJointGetAnchorB(constraint)
}

// C signature:
// CP_EXPORT void cpPinJointSetAnchorB(cpConstraint *constraint, cpVect anchorB);
fn C.cpPinJointSetAnchorB(constraint &C.cpConstraint, anchorB C.cpVect)

// pin_joint_set_anchor_b sets the location of the second anchor relative to the second body.
@[inline]
pub fn pin_joint_set_anchor_b(constraint &Constraint, anchorB Vect) {
	C.cpPinJointSetAnchorB(constraint, anchorB)
}

// C signature:
// CP_EXPORT cpFloat cpPinJointGetDist(const cpConstraint *constraint);
fn C.cpPinJointGetDist(constraint &C.cpConstraint) Float

// pin_joint_get_dist gets the distance the joint will maintain between the two anchors.
@[inline]
pub fn pin_joint_get_dist(constraint &Constraint) Float {
	return C.cpPinJointGetDist(constraint)
}

// C signature:
// CP_EXPORT void cpPinJointSetDist(cpConstraint *constraint, cpFloat dist);
fn C.cpPinJointSetDist(constraint &C.cpConstraint, dist Float)

// pin_joint_set_dist sets the distance the joint will maintain between the two anchors.
@[inline]
pub fn pin_joint_set_dist(constraint &Constraint, dist Float) {
	C.cpPinJointSetDist(constraint, dist)
}

//
// cpPivotJoint.h
//

// C signature:
// CP_EXPORT cpBool cpConstraintIsPivotJoint(const cpConstraint *constraint);
fn C.cpConstraintIsPivotJoint(constraint &C.cpConstraint) bool

// is_pivot_joint checks if a constraint is a slide joint.
@[inline]
pub fn (mut constraint Constraint) is_pivot_joint() bool {
	return C.cpConstraintIsPivotJoint(constraint)
}

// C signature:
// CP_EXPORT cpPivotJoint* cpPivotJointAlloc();
fn C.cpPivotJointAlloc() &C.cpPivotJoint

// pivot_joint_alloc allocates a pivot joint
@[inline]
pub fn pivot_joint_alloc() &PivotJoint {
	return C.cpPivotJointAlloc()
}

// C signature:
// CP_EXPORT cpPivotJoint* cpPivotJointInit(cpPivotJoint *joint, cpBody *a, cpBody *b, cpVect anchorA, cpVect anchorB);
fn C.cpPivotJointInit(joint &C.cpPivotJoint, a &C.cpBody, b &C.cpBody, anchorA C.cpVect, anchorB C.cpVect) &C.cpPivotJoint

// init initializes a pivot joint.
@[inline]
pub fn (mut joint PivotJoint) init(a &Body, b &Body, anchorA Vect, anchorB Vect) &PivotJoint {
	return C.cpPivotJointInit(joint, a, b, anchorA, anchorB)
}

// C signature:
// CP_EXPORT cpConstraint* cpPivotJointNew(cpBody *a, cpBody *b, cpVect pivot);
fn C.cpPivotJointNew(a &C.cpBody, b &C.cpBody, pivot C.cpVect) &C.cpConstraint

// pivot_joint_new allocates and initialize a pivot joint.
@[inline]
pub fn pivot_joint_new(a &Body, b &Body, pivot Vect) &Constraint {
	return C.cpPivotJointNew(a, b, pivot)
}

// C signature:
// CP_EXPORT cpConstraint* cpPivotJointNew2(cpBody *a, cpBody *b, cpVect anchorA, cpVect anchorB);
fn C.cpPivotJointNew2(a &C.cpBody, b &C.cpBody, anchorA C.cpVect, anchorB C.cpVect) &C.cpConstraint

// pivot_joint_new2 allocates and initialize a pivot joint with specific anchors.
@[inline]
pub fn pivot_joint_new2(a &Body, b &Body, anchorA Vect, anchorB Vect) &Constraint {
	return C.cpPivotJointNew2(a, b, anchorA, anchorB)
}

// C signature:
// CP_EXPORT cpVect cpPivotJointGetAnchorA(const cpConstraint *constraint);
fn C.cpPivotJointGetAnchorA(constraint &C.cpConstraint) C.cpVect

// pivot_joint_get_anchor_a gets the location of the first anchor relative to the first body.
@[inline]
pub fn pivot_joint_get_anchor_a(constraint &Constraint) Vect {
	return C.cpPivotJointGetAnchorA(constraint)
}

// C signature:
// CP_EXPORT void cpPivotJointSetAnchorA(cpConstraint *constraint, cpVect anchorA);
fn C.cpPivotJointSetAnchorA(constraint &C.cpConstraint, anchorA C.cpVect)

// pivot_joint_set_anchor_a sets the location of the first anchor relative to the first body.
@[inline]
pub fn pivot_joint_set_anchor_a(constraint &Constraint, anchorA Vect) {
	C.cpPivotJointSetAnchorA(constraint, anchorA)
}

// C signature:
// CP_EXPORT cpVect cpPivotJointGetAnchorB(const cpConstraint *constraint);
fn C.cpPivotJointGetAnchorB(constraint &C.cpConstraint) C.cpVect

// pivot_joint_get_anchor_b gets the location of the second anchor relative to the second body.
@[inline]
pub fn pivot_joint_get_anchor_b(constraint &Constraint) Vect {
	return C.cpPivotJointGetAnchorB(constraint)
}

// C signature:
// CP_EXPORT void cpPivotJointSetAnchorB(cpConstraint *constraint, cpVect anchorB);
fn C.cpPivotJointSetAnchorB(constraint &C.cpConstraint, anchorB C.cpVect)

// pivot_joint_set_anchor_b sets the location of the second anchor relative to the second body.
@[inline]
pub fn pivot_joint_set_anchor_b(constraint &Constraint, anchorB Vect) {
	C.cpPivotJointSetAnchorB(constraint, anchorB)
}

//
// cpPolyShape.h
//

// C signature:
// CP_EXPORT cpPolyShape* cpPolyShapeAlloc();
fn C.cpPolyShapeAlloc() &C.cpPolyShape

// poly_shape_alloc allocates a polygon shape.
@[inline]
pub fn poly_shape_alloc() &PolyShape {
	return C.cpPolyShapeAlloc()
}

// C signature:
// CP_EXPORT cpPolyShape* cpPolyShapeInit(cpPolyShape *poly, cpBody *body, int count, const cpVect *verts, cpTransform transform, cpFloat radius);
fn C.cpPolyShapeInit(poly &C.cpPolyShape, body &C.cpBody, count int, verts &C.cpVect, transform C.cpTransform, radius Float) &C.cpPolyShape

// init initializes a polygon shape with rounded corners.
// A convex hull will be created from the vertexes.
@[inline]
pub fn (mut poly PolyShape) init(body &Body, count int, verts &Vect, transform C.cpTransform, radius Float) &PolyShape {
	return C.cpPolyShapeInit(poly, body, count, verts, transform, radius)
}

// C signature:
// CP_EXPORT cpPolyShape* cpPolyShapeInitRaw(cpPolyShape *poly, cpBody *body, int count, const cpVect *verts, cpFloat radius);
fn C.cpPolyShapeInitRaw(poly &C.cpPolyShape, body &C.cpBody, count int, verts &C.cpVect, radius Float) &C.cpPolyShape

// init_raw initializes a polygon shape with rounded corners.
// The vertexes must be convex with a counter-clockwise winding.
@[inline]
pub fn (mut poly PolyShape) init_raw(body &Body, count int, verts &Vect, radius Float) &PolyShape {
	return C.cpPolyShapeInitRaw(poly, body, count, verts, radius)
}

// C signature:
// CP_EXPORT cpShape* cpPolyShapeNew(cpBody *body, int count, const cpVect *verts, cpTransform transform, cpFloat radius);
fn C.cpPolyShapeNew(body &C.cpBody, count int, verts &C.cpVect, transform C.cpTransform, radius Float) &C.cpShape

// poly_shape_new allocates and initialize a polygon shape with rounded corners.
// A convex hull will be created from the vertexes.
@[inline]
pub fn poly_shape_new(body &Body, count int, verts &Vect, transform C.cpTransform, radius Float) &Shape {
	return C.cpPolyShapeNew(body, count, verts, transform, radius)
}

// C signature:
// CP_EXPORT cpShape* cpPolyShapeNewRaw(cpBody *body, int count, const cpVect *verts, cpFloat radius);
fn C.cpPolyShapeNewRaw(body &C.cpBody, count int, verts &C.cpVect, radius Float) &C.cpShape

// poly_shape_new_raw allocates and initialize a polygon shape with rounded corners.
// The vertexes must be convex with a counter-clockwise winding.
@[inline]
pub fn poly_shape_new_raw(body &Body, count int, verts &Vect, radius Float) &Shape {
	return C.cpPolyShapeNewRaw(body, count, verts, radius)
}

// C signature:
// CP_EXPORT cpPolyShape* cpBoxShapeInit(cpPolyShape *poly, cpBody *body, cpFloat width, cpFloat height, cpFloat radius);
fn C.cpBoxShapeInit(poly &C.cpPolyShape, body &C.cpBody, width Float, height Float, radius Float) &C.cpPolyShape

// box_shape_init initializes a box shaped polygon shape with rounded corners.
@[inline]
pub fn box_shape_init(poly &PolyShape, body &Body, width Float, height Float, radius Float) &PolyShape {
	return C.cpBoxShapeInit(poly, body, width, height, radius)
}

// C signature:
// CP_EXPORT cpPolyShape* cpBoxShapeInit2(cpPolyShape *poly, cpBody *body, cpBB box, cpFloat radius);
fn C.cpBoxShapeInit2(poly &C.cpPolyShape, body &C.cpBody, box C.cpBB, radius Float) &C.cpPolyShape

// box_shape_init2 initializes an offset box shaped polygon shape with rounded corners.
@[inline]
pub fn box_shape_init2(poly &PolyShape, body &Body, box BB, radius Float) &PolyShape {
	return C.cpBoxShapeInit2(poly, body, box, radius)
}

// C signature:
// CP_EXPORT cpShape* cpBoxShapeNew(cpBody *body, cpFloat width, cpFloat height, cpFloat radius);
fn C.cpBoxShapeNew(body &C.cpBody, width Float, height Float, radius Float) &C.cpShape

// box_shape_new allocates and initialize a box shaped polygon shape.
@[inline]
pub fn box_shape_new(body &Body, width Float, height Float, radius Float) &Shape {
	return C.cpBoxShapeNew(body, width, height, radius)
}

// C signature:
// CP_EXPORT cpShape* cpBoxShapeNew2(cpBody *body, cpBB box, cpFloat radius);
fn C.cpBoxShapeNew2(body &C.cpBody, box C.cpBB, radius Float) &C.cpShape

// box_shape_new2 allocates and initialize an offset box shaped polygon shape.
@[inline]
pub fn box_shape_new2(body &Body, box BB, radius Float) &Shape {
	return C.cpBoxShapeNew2(body, box, radius)
}

// C signature:
// CP_EXPORT int cpPolyShapeGetCount(const cpShape *shape);
fn C.cpPolyShapeGetCount(shape &C.cpShape) int

// poly_shape_get_count gets the number of verts in a polygon shape.
@[inline]
pub fn poly_shape_get_count(shape &Shape) int {
	return C.cpPolyShapeGetCount(shape)
}

// C signature:
// CP_EXPORT cpVect cpPolyShapeGetVert(const cpShape *shape, int index);
fn C.cpPolyShapeGetVert(shape &C.cpShape, index int) C.cpVect

// poly_shape_get_vert gets the @c ith vertex of a polygon shape.
@[inline]
pub fn poly_shape_get_vert(shape &Shape, index int) Vect {
	return C.cpPolyShapeGetVert(shape, index)
}

// C signature:
// CP_EXPORT cpFloat cpPolyShapeGetRadius(const cpShape *shape);
fn C.cpPolyShapeGetRadius(shape &C.cpShape) Float

// poly_shape_get_radius gets the radius of a polygon shape.
@[inline]
pub fn poly_shape_get_radius(shape &Shape) Float {
	return C.cpPolyShapeGetRadius(shape)
}

//
// cpPolyline.h
//

@[typedef]
struct C.cpPolyline {}

pub type Polyline = C.cpPolyline

// C signature:
// CP_EXPORT void cpPolylineFree(cpPolyline *line);
fn C.cpPolylineFree(line &C.cpPolyline)

// free destroys and free a polyline instance.
@[inline]
pub fn (mut line Polyline) free() {
	C.cpPolylineFree(line)
}

// C signature:
// CP_EXPORT cpBool cpPolylineIsClosed(cpPolyline *line);
fn C.cpPolylineIsClosed(line &C.cpPolyline) bool

// is_closed returnss true if the first vertex is equal to the last.
@[inline]
pub fn (mut line Polyline) is_closed() bool {
	return C.cpPolylineIsClosed(line)
}

// C signature:
// CP_EXPORT cpPolyline *cpPolylineSimplifyCurves(cpPolyline *line, cpFloat tol);
fn C.cpPolylineSimplifyCurves(line &C.cpPolyline, tol Float) &C.cpPolyline
@[inline]
pub fn (mut line Polyline) simplify_curves(tol Float) &Polyline {
	return C.cpPolylineSimplifyCurves(line, tol)
}

// C signature:
// CP_EXPORT cpPolyline *cpPolylineSimplifyVertexes(cpPolyline *line, cpFloat tol);
fn C.cpPolylineSimplifyVertexes(line &C.cpPolyline, tol Float) &C.cpPolyline
@[inline]
pub fn (mut line Polyline) simplify_vertexes(tol Float) &Polyline {
	return C.cpPolylineSimplifyVertexes(line, tol)
}

// C signature:
// CP_EXPORT cpPolyline *cpPolylineToConvexHull(cpPolyline *line, cpFloat tol);
fn C.cpPolylineToConvexHull(line &C.cpPolyline, tol Float) &C.cpPolyline

// to_convex_hull gets the convex hull of a polyline as a looped polyline.
@[inline]
pub fn (mut line Polyline) to_convex_hull(tol Float) &Polyline {
	return C.cpPolylineToConvexHull(line, tol)
}

@[typedef]
struct C.cpPolylineSet {}

pub type PolylineSet = C.cpPolylineSet

// C signature:
// CP_EXPORT cpPolylineSet *cpPolylineSetAlloc();
fn C.cpPolylineSetAlloc() &C.cpPolylineSet

// polyline_set_alloc allocates a new polyline set.
@[inline]
pub fn polyline_set_alloc() &PolylineSet {
	return C.cpPolylineSetAlloc()
}

// C signature:
// CP_EXPORT cpPolylineSet *cpPolylineSetInit(cpPolylineSet *set);
fn C.cpPolylineSetInit(set &C.cpPolylineSet) &C.cpPolylineSet

// init initializes a new polyline set.
@[inline]
pub fn (mut set PolylineSet) init() &PolylineSet {
	return C.cpPolylineSetInit(set)
}

// C signature:
// CP_EXPORT cpPolylineSet *cpPolylineSetNew();
fn C.cpPolylineSetNew() &C.cpPolylineSet

// polyline_set_new allocates and initialize a polyline set.
@[inline]
pub fn polyline_set_new() &PolylineSet {
	return C.cpPolylineSetNew()
}

// C signature:
// CP_EXPORT void cpPolylineSetDestroy(cpPolylineSet *set, cpBool freePolylines);
fn C.cpPolylineSetDestroy(set &C.cpPolylineSet, freePolylines bool)

// destroy destroys a polyline set.
@[inline]
pub fn (mut set PolylineSet) destroy(freePolylines bool) {
	C.cpPolylineSetDestroy(set, freePolylines)
}

// C signature:
// CP_EXPORT void cpPolylineSetFree(cpPolylineSet *set, cpBool freePolylines);
fn C.cpPolylineSetFree(set &C.cpPolylineSet, freePolylines bool)

// free destroys and free a polyline set.
@[inline]
pub fn (mut set PolylineSet) free(freePolylines bool) {
	C.cpPolylineSetFree(set, freePolylines)
}

// C signature:
// CP_EXPORT void cpPolylineSetCollectSegment(cpVect v0, cpVect v1, cpPolylineSet *lines);
fn C.cpPolylineSetCollectSegment(v0 C.cpVect, v1 C.cpVect, lines &C.cpPolylineSet)
@[inline]
pub fn polyline_set_collect_segment(v0 Vect, v1 Vect, lines &PolylineSet) {
	C.cpPolylineSetCollectSegment(v0, v1, lines)
}

// C signature:
// CP_EXPORT cpPolylineSet *cpPolylineConvexDecomposition(cpPolyline *line, cpFloat tol);
fn C.cpPolylineConvexDecomposition(line &C.cpPolyline, tol Float) &C.cpPolylineSet
@[inline]
pub fn (mut line Polyline) convex_decomposition(tol Float) &PolylineSet {
	return C.cpPolylineConvexDecomposition(line, tol)
}

//
// cpRatchetJoint.h
//

// C signature:
// CP_EXPORT cpBool cpConstraintIsRatchetJoint(const cpConstraint *constraint);
fn C.cpConstraintIsRatchetJoint(constraint &C.cpConstraint) bool

// is_ratchet_joint checks if a constraint is a damped rotary springs.
@[inline]
pub fn (mut constraint Constraint) is_ratchet_joint() bool {
	return C.cpConstraintIsRatchetJoint(constraint)
}

// C signature:
// CP_EXPORT cpRatchetJoint* cpRatchetJointAlloc();
fn C.cpRatchetJointAlloc() &C.cpRatchetJoint

// ratchet_joint_alloc allocates a ratchet joint.
@[inline]
pub fn ratchet_joint_alloc() &RatchetJoint {
	return C.cpRatchetJointAlloc()
}

// C signature:
// CP_EXPORT cpRatchetJoint* cpRatchetJointInit(cpRatchetJoint *joint, cpBody *a, cpBody *b, cpFloat phase, cpFloat ratchet);
fn C.cpRatchetJointInit(joint &C.cpRatchetJoint, a &C.cpBody, b &C.cpBody, phase Float, ratchet Float) &C.cpRatchetJoint

// init initializes a ratched joint.
@[inline]
pub fn (mut joint RatchetJoint) init(a &Body, b &Body, phase Float, ratchet Float) &RatchetJoint {
	return C.cpRatchetJointInit(joint, a, b, phase, ratchet)
}

// C signature:
// CP_EXPORT cpConstraint* cpRatchetJointNew(cpBody *a, cpBody *b, cpFloat phase, cpFloat ratchet);
fn C.cpRatchetJointNew(a &C.cpBody, b &C.cpBody, phase Float, ratchet Float) &C.cpConstraint

// ratchet_joint_new allocates and initialize a ratchet joint.
@[inline]
pub fn ratchet_joint_new(a &Body, b &Body, phase Float, ratchet Float) &Constraint {
	return C.cpRatchetJointNew(a, b, phase, ratchet)
}

// C signature:
// CP_EXPORT cpFloat cpRatchetJointGetAngle(const cpConstraint *constraint);
fn C.cpRatchetJointGetAngle(constraint &C.cpConstraint) Float

// ratchet_joint_get_angle gets the angle of the current ratchet tooth.
@[inline]
pub fn ratchet_joint_get_angle(constraint &Constraint) Float {
	return C.cpRatchetJointGetAngle(constraint)
}

// C signature:
// CP_EXPORT void cpRatchetJointSetAngle(cpConstraint *constraint, cpFloat angle);
fn C.cpRatchetJointSetAngle(constraint &C.cpConstraint, angle Float)

// ratchet_joint_set_angle sets the angle of the current ratchet tooth.
@[inline]
pub fn ratchet_joint_set_angle(constraint &Constraint, angle Float) {
	C.cpRatchetJointSetAngle(constraint, angle)
}

// C signature:
// CP_EXPORT cpFloat cpRatchetJointGetPhase(const cpConstraint *constraint);
fn C.cpRatchetJointGetPhase(constraint &C.cpConstraint) Float

// ratchet_joint_get_phase gets the phase offset of the ratchet.
@[inline]
pub fn ratchet_joint_get_phase(constraint &Constraint) Float {
	return C.cpRatchetJointGetPhase(constraint)
}

// C signature:
// CP_EXPORT void cpRatchetJointSetPhase(cpConstraint *constraint, cpFloat phase);
fn C.cpRatchetJointSetPhase(constraint &C.cpConstraint, phase Float)

// ratchet_joint_set_phase gets the phase offset of the ratchet.
@[inline]
pub fn ratchet_joint_set_phase(constraint &Constraint, phase Float) {
	C.cpRatchetJointSetPhase(constraint, phase)
}

// C signature:
// CP_EXPORT cpFloat cpRatchetJointGetRatchet(const cpConstraint *constraint);
fn C.cpRatchetJointGetRatchet(constraint &C.cpConstraint) Float

// ratchet_joint_get_ratchet gets the angular distance of each ratchet.
@[inline]
pub fn ratchet_joint_get_ratchet(constraint &Constraint) Float {
	return C.cpRatchetJointGetRatchet(constraint)
}

// C signature:
// CP_EXPORT void cpRatchetJointSetRatchet(cpConstraint *constraint, cpFloat ratchet);
fn C.cpRatchetJointSetRatchet(constraint &C.cpConstraint, ratchet Float)

// ratchet_joint_set_ratchet sets the angular distance of each ratchet.
@[inline]
pub fn ratchet_joint_set_ratchet(constraint &Constraint, ratchet Float) {
	C.cpRatchetJointSetRatchet(constraint, ratchet)
}

//
// cpRobust.h
//

//
// cpRotaryLimitJoint.h
//

// C signature:
// CP_EXPORT cpBool cpConstraintIsRotaryLimitJoint(const cpConstraint *constraint);
fn C.cpConstraintIsRotaryLimitJoint(constraint &C.cpConstraint) bool

// is_rotary_limit_joint checks if a constraint is a damped rotary springs.
@[inline]
pub fn (mut constraint Constraint) is_rotary_limit_joint() bool {
	return C.cpConstraintIsRotaryLimitJoint(constraint)
}

// C signature:
// CP_EXPORT cpRotaryLimitJoint* cpRotaryLimitJointAlloc();
fn C.cpRotaryLimitJointAlloc() &C.cpRotaryLimitJoint

// rotary_limit_joint_alloc allocates a damped rotary limit joint.
@[inline]
pub fn rotary_limit_joint_alloc() &RotaryLimitJoint {
	return C.cpRotaryLimitJointAlloc()
}

// C signature:
// CP_EXPORT cpRotaryLimitJoint* cpRotaryLimitJointInit(cpRotaryLimitJoint *joint, cpBody *a, cpBody *b, cpFloat min, cpFloat max);
fn C.cpRotaryLimitJointInit(joint &C.cpRotaryLimitJoint, a &C.cpBody, b &C.cpBody, min Float, max Float) &C.cpRotaryLimitJoint

// init initializes a damped rotary limit joint.
@[inline]
pub fn (mut joint RotaryLimitJoint) init(a &Body, b &Body, min Float, max Float) &RotaryLimitJoint {
	return C.cpRotaryLimitJointInit(joint, a, b, min, max)
}

// C signature:
// CP_EXPORT cpConstraint* cpRotaryLimitJointNew(cpBody *a, cpBody *b, cpFloat min, cpFloat max);
fn C.cpRotaryLimitJointNew(a &C.cpBody, b &C.cpBody, min Float, max Float) &C.cpConstraint

// rotary_limit_joint_new allocates and initialize a damped rotary limit joint.
@[inline]
pub fn rotary_limit_joint_new(a &Body, b &Body, min Float, max Float) &Constraint {
	return C.cpRotaryLimitJointNew(a, b, min, max)
}

// C signature:
// CP_EXPORT cpFloat cpRotaryLimitJointGetMin(const cpConstraint *constraint);
fn C.cpRotaryLimitJointGetMin(constraint &C.cpConstraint) Float

// rotary_limit_joint_get_min gets the minimum distance the joint will maintain between the two anchors.
@[inline]
pub fn rotary_limit_joint_get_min(constraint &Constraint) Float {
	return C.cpRotaryLimitJointGetMin(constraint)
}

// C signature:
// CP_EXPORT void cpRotaryLimitJointSetMin(cpConstraint *constraint, cpFloat min);
fn C.cpRotaryLimitJointSetMin(constraint &C.cpConstraint, min Float)

// rotary_limit_joint_set_min sets the minimum distance the joint will maintain between the two anchors.
@[inline]
pub fn rotary_limit_joint_set_min(constraint &Constraint, min Float) {
	C.cpRotaryLimitJointSetMin(constraint, min)
}

// C signature:
// CP_EXPORT cpFloat cpRotaryLimitJointGetMax(const cpConstraint *constraint);
fn C.cpRotaryLimitJointGetMax(constraint &C.cpConstraint) Float

// rotary_limit_joint_get_max gets the maximum distance the joint will maintain between the two anchors.
@[inline]
pub fn rotary_limit_joint_get_max(constraint &Constraint) Float {
	return C.cpRotaryLimitJointGetMax(constraint)
}

// C signature:
// CP_EXPORT void cpRotaryLimitJointSetMax(cpConstraint *constraint, cpFloat max);
fn C.cpRotaryLimitJointSetMax(constraint &C.cpConstraint, max Float)

// rotary_limit_joint_set_max sets the maximum distance the joint will maintain between the two anchors.
@[inline]
pub fn rotary_limit_joint_set_max(constraint &Constraint, max Float) {
	C.cpRotaryLimitJointSetMax(constraint, max)
}

//
// cpShape.h
//

@[typedef]
struct C.cpPointQueryInfo {}

pub type PointQueryInfo = C.cpPointQueryInfo

@[typedef]
struct C.cpSegmentQueryInfo {}

pub type SegmentQueryInfo = C.cpSegmentQueryInfo

@[typedef]
struct C.cpShapeFilter {}

pub type ShapeFilter = C.cpShapeFilter

// C signature:
// CP_EXPORT void cpShapeDestroy(cpShape *shape);
fn C.cpShapeDestroy(shape &C.cpShape)

// destroy destroys a shape.
@[inline]
pub fn (mut shape Shape) destroy() {
	C.cpShapeDestroy(shape)
}

// C signature:
// CP_EXPORT void cpShapeFree(cpShape *shape);
fn C.cpShapeFree(shape &C.cpShape)

// free destroys and Free a shape.
@[inline]
pub fn (mut shape Shape) free() {
	C.cpShapeFree(shape)
}

// C signature:
// CP_EXPORT cpBB cpShapeCacheBB(cpShape *shape);
fn C.cpShapeCacheBB(shape &C.cpShape) C.cpBB

// cache_b_b update,s cache and return the bounding box of a shape based on the body it's attached to.
@[inline]
pub fn (mut shape Shape) cache_b_b() BB {
	return C.cpShapeCacheBB(shape)
}

// C signature:
// CP_EXPORT cpBB cpShapeUpdate(cpShape *shape, cpTransform transform);
fn C.cpShapeUpdate(shape &C.cpShape, transform C.cpTransform) C.cpBB

// update update,s cache and return the bounding box of a shape with an explicit transformation.
@[inline]
pub fn (mut shape Shape) update(transform C.cpTransform) BB {
	return C.cpShapeUpdate(shape, transform)
}

// C signature:
// CP_EXPORT cpFloat cpShapePointQuery(const cpShape *shape, cpVect p, cpPointQueryInfo *out);
fn C.cpShapePointQuery(shape &C.cpShape, p C.cpVect, out &C.cpPointQueryInfo) Float

// point_query performs a nearest point query. It finds the closest point on the surface of shape to a specific point.
// The value returned is the distance between the points. A negative distance means the point is inside the shape.
@[inline]
pub fn (mut shape Shape) point_query(p Vect, out &PointQueryInfo) Float {
	return C.cpShapePointQuery(shape, p, out)
}

// C signature:
// CP_EXPORT cpBool cpShapeSegmentQuery(const cpShape *shape, cpVect a, cpVect b, cpFloat radius, cpSegmentQueryInfo *info);
fn C.cpShapeSegmentQuery(shape &C.cpShape, a C.cpVect, b C.cpVect, radius Float, info &C.cpSegmentQueryInfo) bool

// segment_query performs a segment query against a shape. @c info must be a pointer to a valid cpSegmentQueryInfo structure.
@[inline]
pub fn (mut shape Shape) segment_query(a Vect, b Vect, radius Float, info &SegmentQueryInfo) bool {
	return C.cpShapeSegmentQuery(shape, a, b, radius, info)
}

// C signature:
// CP_EXPORT cpContactPointSet cpShapesCollide(const cpShape *a, const cpShape *b);
fn C.cpShapesCollide(a &C.cpShape, b &C.cpShape) C.cpContactPointSet

// s_collide returns contact information about two shapes.
@[inline]
pub fn (mut a Shape) s_collide(b &Shape) ContactPointSet {
	return C.cpShapesCollide(a, b)
}

// C signature:
// CP_EXPORT cpSpace* cpShapeGetSpace(const cpShape *shape);
fn C.cpShapeGetSpace(shape &C.cpShape) &C.cpSpace

// get_space thes cpSpace this body is added to.
@[inline]
pub fn (mut shape Shape) get_space() &Space {
	return C.cpShapeGetSpace(shape)
}

// C signature:
// CP_EXPORT cpBody* cpShapeGetBody(const cpShape *shape);
fn C.cpShapeGetBody(shape &C.cpShape) &C.cpBody

// get_body thes cpBody this shape is connected to.
@[inline]
pub fn (mut shape Shape) get_body() &Body {
	return C.cpShapeGetBody(shape)
}

// C signature:
// CP_EXPORT void cpShapeSetBody(cpShape *shape, cpBody *body);
fn C.cpShapeSetBody(shape &C.cpShape, body &C.cpBody)

// set_body sets the cpBody this shape is connected to.
// Can only be used if the shape is not currently added to a space.
@[inline]
pub fn (mut shape Shape) set_body(body &Body) {
	C.cpShapeSetBody(shape, body)
}

// C signature:
// CP_EXPORT cpFloat cpShapeGetMass(cpShape *shape);
fn C.cpShapeGetMass(shape &C.cpShape) Float

// get_mass gets the mass of the shape if you are having Chipmunk calculate mass properties for you.
@[inline]
pub fn (mut shape Shape) get_mass() Float {
	return C.cpShapeGetMass(shape)
}

// C signature:
// CP_EXPORT void cpShapeSetMass(cpShape *shape, cpFloat mass);
fn C.cpShapeSetMass(shape &C.cpShape, mass Float)

// set_mass sets the mass of this shape to have Chipmunk calculate mass properties for you.
@[inline]
pub fn (mut shape Shape) set_mass(mass Float) {
	C.cpShapeSetMass(shape, mass)
}

// C signature:
// CP_EXPORT cpFloat cpShapeGetDensity(cpShape *shape);
fn C.cpShapeGetDensity(shape &C.cpShape) Float

// get_density gets the density of the shape if you are having Chipmunk calculate mass properties for you.
@[inline]
pub fn (mut shape Shape) get_density() Float {
	return C.cpShapeGetDensity(shape)
}

// C signature:
// CP_EXPORT void cpShapeSetDensity(cpShape *shape, cpFloat density);
fn C.cpShapeSetDensity(shape &C.cpShape, density Float)

// set_density sets the density  of this shape to have Chipmunk calculate mass properties for you.
@[inline]
pub fn (mut shape Shape) set_density(density Float) {
	C.cpShapeSetDensity(shape, density)
}

// C signature:
// CP_EXPORT cpFloat cpShapeGetMoment(cpShape *shape);
fn C.cpShapeGetMoment(shape &C.cpShape) Float

// get_moment gets the calculated moment of inertia for this shape.
@[inline]
pub fn (mut shape Shape) get_moment() Float {
	return C.cpShapeGetMoment(shape)
}

// C signature:
// CP_EXPORT cpFloat cpShapeGetArea(cpShape *shape);
fn C.cpShapeGetArea(shape &C.cpShape) Float

// get_area gets the calculated area of this shape.
@[inline]
pub fn (mut shape Shape) get_area() Float {
	return C.cpShapeGetArea(shape)
}

// C signature:
// CP_EXPORT cpVect cpShapeGetCenterOfGravity(cpShape *shape);
fn C.cpShapeGetCenterOfGravity(shape &C.cpShape) C.cpVect

// get_center_of_gravity gets the centroid of this shape.
@[inline]
pub fn (mut shape Shape) get_center_of_gravity() Vect {
	return C.cpShapeGetCenterOfGravity(shape)
}

// C signature:
// CP_EXPORT cpBB cpShapeGetBB(const cpShape *shape);
fn C.cpShapeGetBB(shape &C.cpShape) C.cpBB

// get_b_b gets the bounding box that contains the shape given it's current position and angle.
@[inline]
pub fn (mut shape Shape) get_b_b() BB {
	return C.cpShapeGetBB(shape)
}

// C signature:
// CP_EXPORT cpBool cpShapeGetSensor(const cpShape *shape);
fn C.cpShapeGetSensor(shape &C.cpShape) bool

// get_sensor gets if the shape is set to be a sensor or not.
@[inline]
pub fn (mut shape Shape) get_sensor() bool {
	return C.cpShapeGetSensor(shape)
}

// C signature:
// CP_EXPORT void cpShapeSetSensor(cpShape *shape, cpBool sensor);
fn C.cpShapeSetSensor(shape &C.cpShape, sensor bool)

// set_sensor sets if the shape is a sensor or not.
@[inline]
pub fn (mut shape Shape) set_sensor(sensor bool) {
	C.cpShapeSetSensor(shape, sensor)
}

// C signature:
// CP_EXPORT cpFloat cpShapeGetElasticity(const cpShape *shape);
fn C.cpShapeGetElasticity(shape &C.cpShape) Float

// get_elasticity gets the elasticity of this shape.
@[inline]
pub fn (mut shape Shape) get_elasticity() Float {
	return C.cpShapeGetElasticity(shape)
}

// C signature:
// CP_EXPORT void cpShapeSetElasticity(cpShape *shape, cpFloat elasticity);
fn C.cpShapeSetElasticity(shape &C.cpShape, elasticity Float)

// set_elasticity sets the elasticity of this shape.
@[inline]
pub fn (mut shape Shape) set_elasticity(elasticity Float) {
	C.cpShapeSetElasticity(shape, elasticity)
}

// C signature:
// CP_EXPORT cpFloat cpShapeGetFriction(const cpShape *shape);
fn C.cpShapeGetFriction(shape &C.cpShape) Float

// get_friction gets the friction of this shape.
@[inline]
pub fn (mut shape Shape) get_friction() Float {
	return C.cpShapeGetFriction(shape)
}

// C signature:
// CP_EXPORT void cpShapeSetFriction(cpShape *shape, cpFloat friction);
fn C.cpShapeSetFriction(shape &C.cpShape, friction Float)

// set_friction sets the friction of this shape.
@[inline]
pub fn (mut shape Shape) set_friction(friction Float) {
	C.cpShapeSetFriction(shape, friction)
}

// C signature:
// CP_EXPORT cpVect cpShapeGetSurfaceVelocity(const cpShape *shape);
fn C.cpShapeGetSurfaceVelocity(shape &C.cpShape) C.cpVect

// get_surface_velocity gets the surface velocity of this shape.
@[inline]
pub fn (mut shape Shape) get_surface_velocity() Vect {
	return C.cpShapeGetSurfaceVelocity(shape)
}

// C signature:
// CP_EXPORT void cpShapeSetSurfaceVelocity(cpShape *shape, cpVect surfaceVelocity);
fn C.cpShapeSetSurfaceVelocity(shape &C.cpShape, surfaceVelocity C.cpVect)

// set_surface_velocity sets the surface velocity of this shape.
@[inline]
pub fn (mut shape Shape) set_surface_velocity(surfaceVelocity Vect) {
	C.cpShapeSetSurfaceVelocity(shape, surfaceVelocity)
}

// C signature:
// CP_EXPORT cpDataPointer cpShapeGetUserData(const cpShape *shape);
fn C.cpShapeGetUserData(shape &C.cpShape) C.cpDataPointer

// get_user_data gets the user definable data pointer of this shape.
@[inline]
pub fn (mut shape Shape) get_user_data() C.cpDataPointer {
	return C.cpShapeGetUserData(shape)
}

// C signature:
// CP_EXPORT void cpShapeSetUserData(cpShape *shape, cpDataPointer userData);
fn C.cpShapeSetUserData(shape &C.cpShape, userData C.cpDataPointer)

// set_user_data sets the user definable data pointer of this shape.
@[inline]
pub fn (mut shape Shape) set_user_data(userData C.cpDataPointer) {
	C.cpShapeSetUserData(shape, userData)
}

// C signature:
// CP_EXPORT cpCollisionType cpShapeGetCollisionType(const cpShape *shape);
fn C.cpShapeGetCollisionType(shape &C.cpShape) C.cpCollisionType

// get_collision_type sets the collision type of this shape.
@[inline]
pub fn (mut shape Shape) get_collision_type() C.cpCollisionType {
	return C.cpShapeGetCollisionType(shape)
}

// C signature:
// CP_EXPORT void cpShapeSetCollisionType(cpShape *shape, cpCollisionType collisionType);
fn C.cpShapeSetCollisionType(shape &C.cpShape, collisionType C.cpCollisionType)

// set_collision_type gets the collision type of this shape.
@[inline]
pub fn (mut shape Shape) set_collision_type(collisionType C.cpCollisionType) {
	C.cpShapeSetCollisionType(shape, collisionType)
}

// C signature:
// CP_EXPORT cpShapeFilter cpShapeGetFilter(const cpShape *shape);
fn C.cpShapeGetFilter(shape &C.cpShape) C.cpShapeFilter

// get_filter gets the collision filtering parameters of this shape.
@[inline]
pub fn (mut shape Shape) get_filter() ShapeFilter {
	return C.cpShapeGetFilter(shape)
}

// C signature:
// CP_EXPORT void cpShapeSetFilter(cpShape *shape, cpShapeFilter filter);
fn C.cpShapeSetFilter(shape &C.cpShape, filter C.cpShapeFilter)

// set_filter sets the collision filtering parameters of this shape.
@[inline]
pub fn (mut shape Shape) set_filter(filter ShapeFilter) {
	C.cpShapeSetFilter(shape, filter)
}

// C signature:
// CP_EXPORT cpCircleShape* cpCircleShapeAlloc();
fn C.cpCircleShapeAlloc() &C.cpCircleShape

// circle_shape_alloc allocates a circle shape.
@[inline]
pub fn circle_shape_alloc() &CircleShape {
	return C.cpCircleShapeAlloc()
}

// C signature:
// CP_EXPORT cpCircleShape* cpCircleShapeInit(cpCircleShape *circle, cpBody *body, cpFloat radius, cpVect offset);
fn C.cpCircleShapeInit(circle &C.cpCircleShape, body &C.cpBody, radius Float, offset C.cpVect) &C.cpCircleShape

// init initializes a circle shape.
@[inline]
pub fn (mut circle CircleShape) init(body &Body, radius Float, offset Vect) &CircleShape {
	return C.cpCircleShapeInit(circle, body, radius, offset)
}

// C signature:
// CP_EXPORT cpShape* cpCircleShapeNew(cpBody *body, cpFloat radius, cpVect offset);
fn C.cpCircleShapeNew(body &C.cpBody, radius Float, offset C.cpVect) &C.cpShape

// circle_shape_new allocates and initialize a circle shape.
@[inline]
pub fn circle_shape_new(body &Body, radius Float, offset Vect) &Shape {
	return C.cpCircleShapeNew(body, radius, offset)
}

// C signature:
// CP_EXPORT cpVect cpCircleShapeGetOffset(const cpShape *shape);
fn C.cpCircleShapeGetOffset(shape &C.cpShape) C.cpVect

// circle_shape_get_offset gets the offset of a circle shape.
@[inline]
pub fn circle_shape_get_offset(shape &Shape) Vect {
	return C.cpCircleShapeGetOffset(shape)
}

// C signature:
// CP_EXPORT cpFloat cpCircleShapeGetRadius(const cpShape *shape);
fn C.cpCircleShapeGetRadius(shape &C.cpShape) Float

// circle_shape_get_radius gets the radius of a circle shape.
@[inline]
pub fn circle_shape_get_radius(shape &Shape) Float {
	return C.cpCircleShapeGetRadius(shape)
}

// C signature:
// CP_EXPORT cpSegmentShape* cpSegmentShapeAlloc();
fn C.cpSegmentShapeAlloc() &C.cpSegmentShape

// segment_shape_alloc allocates a segment shape.
@[inline]
pub fn segment_shape_alloc() &SegmentShape {
	return C.cpSegmentShapeAlloc()
}

// C signature:
// CP_EXPORT cpSegmentShape* cpSegmentShapeInit(cpSegmentShape *seg, cpBody *body, cpVect a, cpVect b, cpFloat radius);
fn C.cpSegmentShapeInit(seg &C.cpSegmentShape, body &C.cpBody, a C.cpVect, b C.cpVect, radius Float) &C.cpSegmentShape

// init initializes a segment shape.
@[inline]
pub fn (mut seg SegmentShape) init(body &Body, a Vect, b Vect, radius Float) &SegmentShape {
	return C.cpSegmentShapeInit(seg, body, a, b, radius)
}

// C signature:
// CP_EXPORT cpShape* cpSegmentShapeNew(cpBody *body, cpVect a, cpVect b, cpFloat radius);
fn C.cpSegmentShapeNew(body &C.cpBody, a C.cpVect, b C.cpVect, radius Float) &C.cpShape

// segment_shape_new allocates and initialize a segment shape.
@[inline]
pub fn segment_shape_new(body &Body, a Vect, b Vect, radius Float) &Shape {
	return C.cpSegmentShapeNew(body, a, b, radius)
}

// C signature:
// CP_EXPORT void cpSegmentShapeSetNeighbors(cpShape *shape, cpVect prev, cpVect next);
fn C.cpSegmentShapeSetNeighbors(shape &C.cpShape, prev C.cpVect, next C.cpVect)

// segment_shape_set_neighbors lets Chipmunk know about the geometry of adjacent segments to avoid colliding with endcaps.
@[inline]
pub fn segment_shape_set_neighbors(shape &Shape, prev Vect, next Vect) {
	C.cpSegmentShapeSetNeighbors(shape, prev, next)
}

// C signature:
// CP_EXPORT cpVect cpSegmentShapeGetA(const cpShape *shape);
fn C.cpSegmentShapeGetA(shape &C.cpShape) C.cpVect

// segment_shape_get_a gets the first endpoint of a segment shape.
@[inline]
pub fn segment_shape_get_a(shape &Shape) Vect {
	return C.cpSegmentShapeGetA(shape)
}

// C signature:
// CP_EXPORT cpVect cpSegmentShapeGetB(const cpShape *shape);
fn C.cpSegmentShapeGetB(shape &C.cpShape) C.cpVect

// segment_shape_get_b gets the second endpoint of a segment shape.
@[inline]
pub fn segment_shape_get_b(shape &Shape) Vect {
	return C.cpSegmentShapeGetB(shape)
}

// C signature:
// CP_EXPORT cpVect cpSegmentShapeGetNormal(const cpShape *shape);
fn C.cpSegmentShapeGetNormal(shape &C.cpShape) C.cpVect

// segment_shape_get_normal gets the normal of a segment shape.
@[inline]
pub fn segment_shape_get_normal(shape &Shape) Vect {
	return C.cpSegmentShapeGetNormal(shape)
}

// C signature:
// CP_EXPORT cpFloat cpSegmentShapeGetRadius(const cpShape *shape);
fn C.cpSegmentShapeGetRadius(shape &C.cpShape) Float

// segment_shape_get_radius gets the first endpoint of a segment shape.
@[inline]
pub fn segment_shape_get_radius(shape &Shape) Float {
	return C.cpSegmentShapeGetRadius(shape)
}

//
// cpSimpleMotor.h
//

@[typedef]
struct C.cpSimpleMotor {}

pub type SimpleMotor = C.cpSimpleMotor

// C signature:
// CP_EXPORT cpBool cpConstraintIsSimpleMotor(const cpConstraint *constraint);
fn C.cpConstraintIsSimpleMotor(constraint &C.cpConstraint) bool

// is_simple_motor checks if a constraint is a damped rotary springs.
@[inline]
pub fn (mut constraint Constraint) is_simple_motor() bool {
	return C.cpConstraintIsSimpleMotor(constraint)
}

// C signature:
// CP_EXPORT cpSimpleMotor* cpSimpleMotorAlloc();
fn C.cpSimpleMotorAlloc() &C.cpSimpleMotor

// simple_motor_alloc allocates a simple motor.
@[inline]
pub fn simple_motor_alloc() &SimpleMotor {
	return C.cpSimpleMotorAlloc()
}

// C signature:
// CP_EXPORT cpSimpleMotor* cpSimpleMotorInit(cpSimpleMotor *joint, cpBody *a, cpBody *b, cpFloat rate);
fn C.cpSimpleMotorInit(joint &C.cpSimpleMotor, a &C.cpBody, b &C.cpBody, rate Float) &C.cpSimpleMotor

// init initializes a simple motor.
@[inline]
pub fn (mut joint SimpleMotor) init(a &Body, b &Body, rate Float) &SimpleMotor {
	return C.cpSimpleMotorInit(joint, a, b, rate)
}

// C signature:
// CP_EXPORT cpConstraint* cpSimpleMotorNew(cpBody *a, cpBody *b, cpFloat rate);
fn C.cpSimpleMotorNew(a &C.cpBody, b &C.cpBody, rate Float) &C.cpConstraint

// simple_motor_new allocates and initialize a simple motor.
@[inline]
pub fn simple_motor_new(a &Body, b &Body, rate Float) &Constraint {
	return C.cpSimpleMotorNew(a, b, rate)
}

// C signature:
// CP_EXPORT cpFloat cpSimpleMotorGetRate(const cpConstraint *constraint);
fn C.cpSimpleMotorGetRate(constraint &C.cpConstraint) Float

// simple_motor_get_rate gets the rate of the motor.
@[inline]
pub fn simple_motor_get_rate(constraint &Constraint) Float {
	return C.cpSimpleMotorGetRate(constraint)
}

// C signature:
// CP_EXPORT void cpSimpleMotorSetRate(cpConstraint *constraint, cpFloat rate);
fn C.cpSimpleMotorSetRate(constraint &C.cpConstraint, rate Float)

// simple_motor_set_rate sets the rate of the motor.
@[inline]
pub fn simple_motor_set_rate(constraint &Constraint, rate Float) {
	C.cpSimpleMotorSetRate(constraint, rate)
}

//
// cpSlideJoint.h
//

// C signature:
// CP_EXPORT cpBool cpConstraintIsSlideJoint(const cpConstraint *constraint);
fn C.cpConstraintIsSlideJoint(constraint &C.cpConstraint) bool

// is_slide_joint checks if a constraint is a slide joint.
@[inline]
pub fn (mut constraint Constraint) is_slide_joint() bool {
	return C.cpConstraintIsSlideJoint(constraint)
}

// C signature:
// CP_EXPORT cpSlideJoint* cpSlideJointAlloc();
fn C.cpSlideJointAlloc() &C.cpSlideJoint

// slide_joint_alloc allocates a slide joint.
@[inline]
pub fn slide_joint_alloc() &SlideJoint {
	return C.cpSlideJointAlloc()
}

// C signature:
// CP_EXPORT cpSlideJoint* cpSlideJointInit(cpSlideJoint *joint, cpBody *a, cpBody *b, cpVect anchorA, cpVect anchorB, cpFloat min, cpFloat max);
fn C.cpSlideJointInit(joint &C.cpSlideJoint, a &C.cpBody, b &C.cpBody, anchorA C.cpVect, anchorB C.cpVect, min Float, max Float) &C.cpSlideJoint

// init initializes a slide joint.
@[inline]
pub fn (mut joint SlideJoint) init(a &Body, b &Body, anchorA Vect, anchorB Vect, min Float, max Float) &SlideJoint {
	return C.cpSlideJointInit(joint, a, b, anchorA, anchorB, min, max)
}

// C signature:
// CP_EXPORT cpConstraint* cpSlideJointNew(cpBody *a, cpBody *b, cpVect anchorA, cpVect anchorB, cpFloat min, cpFloat max);
fn C.cpSlideJointNew(a &C.cpBody, b &C.cpBody, anchorA C.cpVect, anchorB C.cpVect, min Float, max Float) &C.cpConstraint

// slide_joint_new allocates and initialize a slide joint.
@[inline]
pub fn slide_joint_new(a &Body, b &Body, anchorA Vect, anchorB Vect, min Float, max Float) &Constraint {
	return C.cpSlideJointNew(a, b, anchorA, anchorB, min, max)
}

// C signature:
// CP_EXPORT cpVect cpSlideJointGetAnchorA(const cpConstraint *constraint);
fn C.cpSlideJointGetAnchorA(constraint &C.cpConstraint) C.cpVect

// slide_joint_get_anchor_a gets the location of the first anchor relative to the first body.
@[inline]
pub fn slide_joint_get_anchor_a(constraint &Constraint) Vect {
	return C.cpSlideJointGetAnchorA(constraint)
}

// C signature:
// CP_EXPORT void cpSlideJointSetAnchorA(cpConstraint *constraint, cpVect anchorA);
fn C.cpSlideJointSetAnchorA(constraint &C.cpConstraint, anchorA C.cpVect)

// slide_joint_set_anchor_a sets the location of the first anchor relative to the first body.
@[inline]
pub fn slide_joint_set_anchor_a(constraint &Constraint, anchorA Vect) {
	C.cpSlideJointSetAnchorA(constraint, anchorA)
}

// C signature:
// CP_EXPORT cpVect cpSlideJointGetAnchorB(const cpConstraint *constraint);
fn C.cpSlideJointGetAnchorB(constraint &C.cpConstraint) C.cpVect

// slide_joint_get_anchor_b gets the location of the second anchor relative to the second body.
@[inline]
pub fn slide_joint_get_anchor_b(constraint &Constraint) Vect {
	return C.cpSlideJointGetAnchorB(constraint)
}

// C signature:
// CP_EXPORT void cpSlideJointSetAnchorB(cpConstraint *constraint, cpVect anchorB);
fn C.cpSlideJointSetAnchorB(constraint &C.cpConstraint, anchorB C.cpVect)

// slide_joint_set_anchor_b sets the location of the second anchor relative to the second body.
@[inline]
pub fn slide_joint_set_anchor_b(constraint &Constraint, anchorB Vect) {
	C.cpSlideJointSetAnchorB(constraint, anchorB)
}

// C signature:
// CP_EXPORT cpFloat cpSlideJointGetMin(const cpConstraint *constraint);
fn C.cpSlideJointGetMin(constraint &C.cpConstraint) Float

// slide_joint_get_min gets the minimum distance the joint will maintain between the two anchors.
@[inline]
pub fn slide_joint_get_min(constraint &Constraint) Float {
	return C.cpSlideJointGetMin(constraint)
}

// C signature:
// CP_EXPORT void cpSlideJointSetMin(cpConstraint *constraint, cpFloat min);
fn C.cpSlideJointSetMin(constraint &C.cpConstraint, min Float)

// slide_joint_set_min sets the minimum distance the joint will maintain between the two anchors.
@[inline]
pub fn slide_joint_set_min(constraint &Constraint, min Float) {
	C.cpSlideJointSetMin(constraint, min)
}

// C signature:
// CP_EXPORT cpFloat cpSlideJointGetMax(const cpConstraint *constraint);
fn C.cpSlideJointGetMax(constraint &C.cpConstraint) Float

// slide_joint_get_max gets the maximum distance the joint will maintain between the two anchors.
@[inline]
pub fn slide_joint_get_max(constraint &Constraint) Float {
	return C.cpSlideJointGetMax(constraint)
}

// C signature:
// CP_EXPORT void cpSlideJointSetMax(cpConstraint *constraint, cpFloat max);
fn C.cpSlideJointSetMax(constraint &C.cpConstraint, max Float)

// slide_joint_set_max sets the maximum distance the joint will maintain between the two anchors.
@[inline]
pub fn slide_joint_set_max(constraint &Constraint, max Float) {
	C.cpSlideJointSetMax(constraint, max)
}

//
// cpSpace.h
//

// C signature:
// CP_EXPORT cpSpace* cpSpaceAlloc();
fn C.cpSpaceAlloc() &C.cpSpace

// space_alloc allocates a cpSpace.
@[inline]
pub fn space_alloc() &Space {
	return C.cpSpaceAlloc()
}

// C signature:
// CP_EXPORT cpSpace* cpSpaceInit(cpSpace *space);
fn C.cpSpaceInit(space &C.cpSpace) &C.cpSpace

// init initializes a cpSpace.
@[inline]
pub fn (mut space Space) init() &Space {
	return C.cpSpaceInit(space)
}

// C signature:
// CP_EXPORT cpSpace* cpSpaceNew();
fn C.cpSpaceNew() &C.cpSpace

// space_new allocates and initialize a cpSpace.
@[inline]
pub fn space_new() &Space {
	return C.cpSpaceNew()
}

// C signature:
// CP_EXPORT void cpSpaceDestroy(cpSpace *space);
fn C.cpSpaceDestroy(space &C.cpSpace)

// destroy destroys a cpSpace.
@[inline]
pub fn (mut space Space) destroy() {
	C.cpSpaceDestroy(space)
}

// C signature:
// CP_EXPORT void cpSpaceFree(cpSpace *space);
fn C.cpSpaceFree(space &C.cpSpace)

// free destroys and free a cpSpace.
@[inline]
pub fn (mut space Space) free() {
	C.cpSpaceFree(space)
}

// C signature:
// CP_EXPORT int cpSpaceGetIterations(const cpSpace *space);
fn C.cpSpaceGetIterations(space &C.cpSpace) int

// get_iterations numbers of iterations to use in the impulse solver to solve contacts and other constraints.
@[inline]
pub fn (mut space Space) get_iterations() int {
	return C.cpSpaceGetIterations(space)
}

// C signature:
// CP_EXPORT void cpSpaceSetIterations(cpSpace *space, int iterations);
fn C.cpSpaceSetIterations(space &C.cpSpace, iterations int)
@[inline]
pub fn (mut space Space) set_iterations(iterations int) {
	C.cpSpaceSetIterations(space, iterations)
}

// C signature:
// CP_EXPORT cpVect cpSpaceGetGravity(const cpSpace *space);
fn C.cpSpaceGetGravity(space &C.cpSpace) C.cpVect

// get_gravity gravitys to pass to rigid bodies when integrating velocity.
@[inline]
pub fn (mut space Space) get_gravity() Vect {
	return C.cpSpaceGetGravity(space)
}

// C signature:
// CP_EXPORT void cpSpaceSetGravity(cpSpace *space, cpVect gravity);
fn C.cpSpaceSetGravity(space &C.cpSpace, gravity C.cpVect)
@[inline]
pub fn (mut space Space) set_gravity(gravity Vect) {
	C.cpSpaceSetGravity(space, gravity)
}

// C signature:
// CP_EXPORT cpFloat cpSpaceGetDamping(const cpSpace *space);
fn C.cpSpaceGetDamping(space &C.cpSpace) Float

// get_damping dampings rate expressed as the fraction of velocity bodies retain each second.
// A value of 0.9 would mean that each body's velocity will drop 10% per second.
// The default value is 1.0, meaning no damping is applied.
// @note This damping value is different than those of cpDampedSpring and cpDampedRotarySpring.
@[inline]
pub fn (mut space Space) get_damping() Float {
	return C.cpSpaceGetDamping(space)
}

// C signature:
// CP_EXPORT void cpSpaceSetDamping(cpSpace *space, cpFloat damping);
fn C.cpSpaceSetDamping(space &C.cpSpace, damping Float)
@[inline]
pub fn (mut space Space) set_damping(damping Float) {
	C.cpSpaceSetDamping(space, damping)
}

// C signature:
// CP_EXPORT cpFloat cpSpaceGetIdleSpeedThreshold(const cpSpace *space);
fn C.cpSpaceGetIdleSpeedThreshold(space &C.cpSpace) Float

// get_idle_speed_threshold speeds threshold for a body to be considered idle.
// The default value of 0 means to let the space guess a good threshold based on gravity.
@[inline]
pub fn (mut space Space) get_idle_speed_threshold() Float {
	return C.cpSpaceGetIdleSpeedThreshold(space)
}

// C signature:
// CP_EXPORT void cpSpaceSetIdleSpeedThreshold(cpSpace *space, cpFloat idleSpeedThreshold);
fn C.cpSpaceSetIdleSpeedThreshold(space &C.cpSpace, idleSpeedThreshold Float)
@[inline]
pub fn (mut space Space) set_idle_speed_threshold(idleSpeedThreshold Float) {
	C.cpSpaceSetIdleSpeedThreshold(space, idleSpeedThreshold)
}

// C signature:
// CP_EXPORT cpFloat cpSpaceGetSleepTimeThreshold(const cpSpace *space);
fn C.cpSpaceGetSleepTimeThreshold(space &C.cpSpace) Float

// get_sleep_time_threshold times a group of bodies must remain idle in order to fall asleep.
// Enabling sleeping also implicitly enables the the contact graph.
// The default value of INFINITY disables the sleeping algorithm.
@[inline]
pub fn (mut space Space) get_sleep_time_threshold() Float {
	return C.cpSpaceGetSleepTimeThreshold(space)
}

// C signature:
// CP_EXPORT void cpSpaceSetSleepTimeThreshold(cpSpace *space, cpFloat sleepTimeThreshold);
fn C.cpSpaceSetSleepTimeThreshold(space &C.cpSpace, sleepTimeThreshold Float)
@[inline]
pub fn (mut space Space) set_sleep_time_threshold(sleepTimeThreshold Float) {
	C.cpSpaceSetSleepTimeThreshold(space, sleepTimeThreshold)
}

// C signature:
// CP_EXPORT cpFloat cpSpaceGetCollisionSlop(const cpSpace *space);
fn C.cpSpaceGetCollisionSlop(space &C.cpSpace) Float

// get_collision_slop amounts of encouraged penetration between colliding shapes.
// Used to reduce oscillating contacts and keep the collision cache warm.
// Defaults to 0.1. If you have poor simulation quality,
// increase this number as much as possible without allowing visible amounts of overlap.
@[inline]
pub fn (mut space Space) get_collision_slop() Float {
	return C.cpSpaceGetCollisionSlop(space)
}

// C signature:
// CP_EXPORT void cpSpaceSetCollisionSlop(cpSpace *space, cpFloat collisionSlop);
fn C.cpSpaceSetCollisionSlop(space &C.cpSpace, collisionSlop Float)
@[inline]
pub fn (mut space Space) set_collision_slop(collisionSlop Float) {
	C.cpSpaceSetCollisionSlop(space, collisionSlop)
}

// C signature:
// CP_EXPORT cpFloat cpSpaceGetCollisionBias(const cpSpace *space);
fn C.cpSpaceGetCollisionBias(space &C.cpSpace) Float

// get_collision_bias determiness how fast overlapping shapes are pushed apart.
// Expressed as a fraction of the error remaining after each second.
// Defaults to pow(1.0 - 0.1, 60.0) meaning that Chipmunk fixes 10% of overlap each frame at 60Hz.
@[inline]
pub fn (mut space Space) get_collision_bias() Float {
	return C.cpSpaceGetCollisionBias(space)
}

// C signature:
// CP_EXPORT void cpSpaceSetCollisionBias(cpSpace *space, cpFloat collisionBias);
fn C.cpSpaceSetCollisionBias(space &C.cpSpace, collisionBias Float)
@[inline]
pub fn (mut space Space) set_collision_bias(collisionBias Float) {
	C.cpSpaceSetCollisionBias(space, collisionBias)
}

// C signature:
// CP_EXPORT cpTimestamp cpSpaceGetCollisionPersistence(const cpSpace *space);
fn C.cpSpaceGetCollisionPersistence(space &C.cpSpace) C.cpTimestamp

// get_collision_persistence numbers of frames that contact information should persist.
// Defaults to 3. There is probably never a reason to change this value.
@[inline]
pub fn (mut space Space) get_collision_persistence() C.cpTimestamp {
	return C.cpSpaceGetCollisionPersistence(space)
}

// C signature:
// CP_EXPORT void cpSpaceSetCollisionPersistence(cpSpace *space, cpTimestamp collisionPersistence);
fn C.cpSpaceSetCollisionPersistence(space &C.cpSpace, collisionPersistence C.cpTimestamp)
@[inline]
pub fn (mut space Space) set_collision_persistence(collisionPersistence C.cpTimestamp) {
	C.cpSpaceSetCollisionPersistence(space, collisionPersistence)
}

// C signature:
// CP_EXPORT cpDataPointer cpSpaceGetUserData(const cpSpace *space);
fn C.cpSpaceGetUserData(space &C.cpSpace) C.cpDataPointer

// get_user_data users definable data pointer.
// Generally this points to your game's controller or game state
// class so you can access it when given a cpSpace reference in a callback.
@[inline]
pub fn (mut space Space) get_user_data() C.cpDataPointer {
	return C.cpSpaceGetUserData(space)
}

// C signature:
// CP_EXPORT void cpSpaceSetUserData(cpSpace *space, cpDataPointer userData);
fn C.cpSpaceSetUserData(space &C.cpSpace, userData C.cpDataPointer)
@[inline]
pub fn (mut space Space) set_user_data(userData C.cpDataPointer) {
	C.cpSpaceSetUserData(space, userData)
}

// C signature:
// CP_EXPORT cpBody* cpSpaceGetStaticBody(const cpSpace *space);
fn C.cpSpaceGetStaticBody(space &C.cpSpace) &C.cpBody

// get_static_body thes Space provided static body for a given cpSpace.
// This is merely provided for convenience and you are not required to use it.
@[inline]
pub fn (mut space Space) get_static_body() &Body {
	return C.cpSpaceGetStaticBody(space)
}

// C signature:
// CP_EXPORT cpFloat cpSpaceGetCurrentTimeStep(const cpSpace *space);
fn C.cpSpaceGetCurrentTimeStep(space &C.cpSpace) Float

// get_current_time_step returnss the current (or most recent) time step used with the given space.
// Useful from callbacks if your time step is not a compile-time global.
@[inline]
pub fn (mut space Space) get_current_time_step() Float {
	return C.cpSpaceGetCurrentTimeStep(space)
}

// C signature:
// CP_EXPORT cpBool cpSpaceIsLocked(cpSpace *space);
fn C.cpSpaceIsLocked(space &C.cpSpace) bool

// is_locked returnss true from inside a callback when objects cannot be added/removed.
@[inline]
pub fn (mut space Space) is_locked() bool {
	return C.cpSpaceIsLocked(space)
}

// C signature:
// CP_EXPORT cpCollisionHandler *cpSpaceAddDefaultCollisionHandler(cpSpace *space);
fn C.cpSpaceAddDefaultCollisionHandler(space &C.cpSpace) &C.cpCollisionHandler

// add_default_collision_handler creates or return the existing collision handler that is called for all collisions that are not handled by a more specific collision handler.
@[inline]
pub fn (mut space Space) add_default_collision_handler() &CollisionHandler {
	return C.cpSpaceAddDefaultCollisionHandler(space)
}

// C signature:
// CP_EXPORT cpCollisionHandler *cpSpaceAddCollisionHandler(cpSpace *space, cpCollisionType a, cpCollisionType b);
fn C.cpSpaceAddCollisionHandler(space &C.cpSpace, a C.cpCollisionType, b C.cpCollisionType) &C.cpCollisionHandler

// add_collision_handler creates or return the existing collision handler for the specified pair of collision types.
// If wildcard handlers are used with either of the collision types, it's the responibility of the custom handler to invoke the wildcard handlers.
@[inline]
pub fn (mut space Space) add_collision_handler(a C.cpCollisionType, b C.cpCollisionType) &CollisionHandler {
	return C.cpSpaceAddCollisionHandler(space, a, b)
}

// C signature:
// CP_EXPORT cpCollisionHandler *cpSpaceAddWildcardHandler(cpSpace *space, cpCollisionType type);
fn C.cpSpaceAddWildcardHandler(space &C.cpSpace, typ C.cpCollisionType) &C.cpCollisionHandler

// add_wildcard_handler creates or return the existing wildcard collision handler for the specified type.
@[inline]
pub fn (mut space Space) add_wildcard_handler(typ C.cpCollisionType) &CollisionHandler {
	return C.cpSpaceAddWildcardHandler(space, typ)
}

// C signature:
// CP_EXPORT cpShape* cpSpaceAddShape(cpSpace *space, cpShape *shape);
fn C.cpSpaceAddShape(space &C.cpSpace, shape &C.cpShape) &C.cpShape

// add_shape adds a collision shape to the simulation.
// If the shape is attached to a static body, it will be added as a static shape.
@[inline]
pub fn (mut space Space) add_shape(shape &Shape) &Shape {
	return C.cpSpaceAddShape(space, shape)
}

// C signature:
// CP_EXPORT cpBody* cpSpaceAddBody(cpSpace *space, cpBody *body);
fn C.cpSpaceAddBody(space &C.cpSpace, body &C.cpBody) &C.cpBody

// add_body adds a rigid body to the simulation.
@[inline]
pub fn (mut space Space) add_body(body &Body) &Body {
	return C.cpSpaceAddBody(space, body)
}

// C signature:
// CP_EXPORT cpConstraint* cpSpaceAddConstraint(cpSpace *space, cpConstraint *constraint);
fn C.cpSpaceAddConstraint(space &C.cpSpace, constraint &C.cpConstraint) &C.cpConstraint

// add_constraint adds a constraint to the simulation.
@[inline]
pub fn (mut space Space) add_constraint(constraint &Constraint) &Constraint {
	return C.cpSpaceAddConstraint(space, constraint)
}

// C signature:
// CP_EXPORT void cpSpaceRemoveShape(cpSpace *space, cpShape *shape);
fn C.cpSpaceRemoveShape(space &C.cpSpace, shape &C.cpShape)

// remove_shape removes a collision shape from the simulation.
@[inline]
pub fn (mut space Space) remove_shape(shape &Shape) {
	C.cpSpaceRemoveShape(space, shape)
}

// C signature:
// CP_EXPORT void cpSpaceRemoveBody(cpSpace *space, cpBody *body);
fn C.cpSpaceRemoveBody(space &C.cpSpace, body &C.cpBody)

// remove_body removes a rigid body from the simulation.
@[inline]
pub fn (mut space Space) remove_body(body &Body) {
	C.cpSpaceRemoveBody(space, body)
}

// C signature:
// CP_EXPORT void cpSpaceRemoveConstraint(cpSpace *space, cpConstraint *constraint);
fn C.cpSpaceRemoveConstraint(space &C.cpSpace, constraint &C.cpConstraint)

// remove_constraint removes a constraint from the simulation.
@[inline]
pub fn (mut space Space) remove_constraint(constraint &Constraint) {
	C.cpSpaceRemoveConstraint(space, constraint)
}

// C signature:
// CP_EXPORT cpBool cpSpaceContainsShape(cpSpace *space, cpShape *shape);
fn C.cpSpaceContainsShape(space &C.cpSpace, shape &C.cpShape) bool

// contains_shape tests if a collision shape has been added to the space.
@[inline]
pub fn (mut space Space) contains_shape(shape &Shape) bool {
	return C.cpSpaceContainsShape(space, shape)
}

// C signature:
// CP_EXPORT cpBool cpSpaceContainsBody(cpSpace *space, cpBody *body);
fn C.cpSpaceContainsBody(space &C.cpSpace, body &C.cpBody) bool

// contains_body tests if a rigid body has been added to the space.
@[inline]
pub fn (mut space Space) contains_body(body &Body) bool {
	return C.cpSpaceContainsBody(space, body)
}

// C signature:
// CP_EXPORT cpBool cpSpaceContainsConstraint(cpSpace *space, cpConstraint *constraint);
fn C.cpSpaceContainsConstraint(space &C.cpSpace, constraint &C.cpConstraint) bool

// contains_constraint tests if a constraint has been added to the space.
@[inline]
pub fn (mut space Space) contains_constraint(constraint &Constraint) bool {
	return C.cpSpaceContainsConstraint(space, constraint)
}

// C signature:
// CP_EXPORT cpBool cpSpaceAddPostStepCallback(cpSpace *space, cpPostStepFunc func, void *key, void *data);
fn C.cpSpaceAddPostStepCallback(space &C.cpSpace, func C.cpPostStepFunc, key voidptr, data voidptr) bool

// add_post_step_callback schedules a post-step callback to be called when cpSpaceStep() finishes.
// You can only register one callback per unique value for @c key.
// Returns true only if @c key has never been scheduled before.
// It's possible to pass @c NULL for @c func if you only want to mark @c key as being used.
@[inline]
pub fn (mut space Space) add_post_step_callback(func C.cpPostStepFunc, key &C.void, data &C.void) bool {
	return C.cpSpaceAddPostStepCallback(space, func, key, data)
}

// C signature:
// CP_EXPORT void cpSpacePointQuery(cpSpace *space, cpVect point, cpFloat maxDistance, cpShapeFilter filter, cpSpacePointQueryFunc func, void *data);
fn C.cpSpacePointQuery(space &C.cpSpace, point C.cpVect, maxDistance Float, filter C.cpShapeFilter, func C.cpSpacePointQueryFunc, data voidptr)

// point_query querys the space at a point and call @c func for each shape found.
@[inline]
pub fn (mut space Space) point_query(point Vect, maxDistance Float, filter ShapeFilter, func C.cpSpacePointQueryFunc, data &C.void) {
	C.cpSpacePointQuery(space, point, maxDistance, filter, func, data)
}

// C signature:
// CP_EXPORT cpShape *cpSpacePointQueryNearest(cpSpace *space, cpVect point, cpFloat maxDistance, cpShapeFilter filter, cpPointQueryInfo *out);
fn C.cpSpacePointQueryNearest(space &C.cpSpace, point C.cpVect, maxDistance Float, filter C.cpShapeFilter, out &C.cpPointQueryInfo) &C.cpShape

// point_query_nearest querys the space at a point and return the nearest shape found. Returns NULL if no shapes were found.
@[inline]
pub fn (mut space Space) point_query_nearest(point Vect, maxDistance Float, filter ShapeFilter, out &PointQueryInfo) &Shape {
	return C.cpSpacePointQueryNearest(space, point, maxDistance, filter, out)
}

// C signature:
// CP_EXPORT void cpSpaceSegmentQuery(cpSpace *space, cpVect start, cpVect end, cpFloat radius, cpShapeFilter filter, cpSpaceSegmentQueryFunc func, void *data);
fn C.cpSpaceSegmentQuery(space &C.cpSpace, start C.cpVect, end C.cpVect, radius Float, filter C.cpShapeFilter, func C.cpSpaceSegmentQueryFunc, data voidptr)

// segment_query performs a directed line segment query (like a raycast) against the space calling @c func for each shape intersected.
@[inline]
pub fn (mut space Space) segment_query(start Vect, end Vect, radius Float, filter ShapeFilter, func C.cpSpaceSegmentQueryFunc, data &C.void) {
	C.cpSpaceSegmentQuery(space, start, end, radius, filter, func, data)
}

// C signature:
// CP_EXPORT cpShape *cpSpaceSegmentQueryFirst(cpSpace *space, cpVect start, cpVect end, cpFloat radius, cpShapeFilter filter, cpSegmentQueryInfo *out);
fn C.cpSpaceSegmentQueryFirst(space &C.cpSpace, start C.cpVect, end C.cpVect, radius Float, filter C.cpShapeFilter, out &C.cpSegmentQueryInfo) &C.cpShape

// segment_query_first performs a directed line segment query (like a raycast) against the space and return the first shape hit. Returns NULL if no shapes were hit.
@[inline]
pub fn (mut space Space) segment_query_first(start Vect, end Vect, radius Float, filter ShapeFilter, out &SegmentQueryInfo) &Shape {
	return C.cpSpaceSegmentQueryFirst(space, start, end, radius, filter, out)
}

// C signature:
// CP_EXPORT void cpSpaceBBQuery(cpSpace *space, cpBB bb, cpShapeFilter filter, cpSpaceBBQueryFunc func, void *data);
fn C.cpSpaceBBQuery(space &C.cpSpace, bb C.cpBB, filter C.cpShapeFilter, func C.cpSpaceBBQueryFunc, data voidptr)

// bb_query performs a fast rectangle query on the space calling @c func for each shape found.
// Only the shape's bounding boxes are checked for overlap, not their full shape.
@[inline]
pub fn (mut space Space) bb_query(bb BB, filter ShapeFilter, func C.cpSpaceBBQueryFunc, data &C.void) {
	C.cpSpaceBBQuery(space, bb, filter, func, data)
}

// C signature:
// CP_EXPORT cpBool cpSpaceShapeQuery(cpSpace *space, cpShape *shape, cpSpaceShapeQueryFunc func, void *data);
fn C.cpSpaceShapeQuery(space &C.cpSpace, shape &C.cpShape, func C.cpSpaceShapeQueryFunc, data voidptr) bool

// shape_query querys a space for any shapes overlapping the given shape and call @c func for each shape found.
@[inline]
pub fn (mut space Space) shape_query(shape &Shape, func C.cpSpaceShapeQueryFunc, data &C.void) bool {
	return C.cpSpaceShapeQuery(space, shape, func, data)
}

// C signature:
// CP_EXPORT void cpSpaceEachBody(cpSpace *space, cpSpaceBodyIteratorFunc func, void *data);
fn C.cpSpaceEachBody(space &C.cpSpace, func C.cpSpaceBodyIteratorFunc, data voidptr)

// each_body calls @c func for each body in the space.
@[inline]
pub fn (mut space Space) each_body(func C.cpSpaceBodyIteratorFunc, data &C.void) {
	C.cpSpaceEachBody(space, func, data)
}

// C signature:
// CP_EXPORT void cpSpaceEachShape(cpSpace *space, cpSpaceShapeIteratorFunc func, void *data);
fn C.cpSpaceEachShape(space &C.cpSpace, func C.cpSpaceShapeIteratorFunc, data voidptr)

// each_shape calls @c func for each shape in the space.
@[inline]
pub fn (mut space Space) each_shape(func C.cpSpaceShapeIteratorFunc, data &C.void) {
	C.cpSpaceEachShape(space, func, data)
}

// C signature:
// CP_EXPORT void cpSpaceEachConstraint(cpSpace *space, cpSpaceConstraintIteratorFunc func, void *data);
fn C.cpSpaceEachConstraint(space &C.cpSpace, func C.cpSpaceConstraintIteratorFunc, data voidptr)

// each_constraint calls @c func for each shape in the space.
@[inline]
pub fn (mut space Space) each_constraint(func C.cpSpaceConstraintIteratorFunc, data &C.void) {
	C.cpSpaceEachConstraint(space, func, data)
}

// C signature:
// CP_EXPORT void cpSpaceReindexStatic(cpSpace *space);
fn C.cpSpaceReindexStatic(space &C.cpSpace)

// reindex_static updates the collision detection info for the static shapes in the space.
@[inline]
pub fn (mut space Space) reindex_static() {
	C.cpSpaceReindexStatic(space)
}

// C signature:
// CP_EXPORT void cpSpaceReindexShape(cpSpace *space, cpShape *shape);
fn C.cpSpaceReindexShape(space &C.cpSpace, shape &C.cpShape)

// reindex_shape updates the collision detection data for a specific shape in the space.
@[inline]
pub fn (mut space Space) reindex_shape(shape &Shape) {
	C.cpSpaceReindexShape(space, shape)
}

// C signature:
// CP_EXPORT void cpSpaceReindexShapesForBody(cpSpace *space, cpBody *body);
fn C.cpSpaceReindexShapesForBody(space &C.cpSpace, body &C.cpBody)

// reindex_shapes_for_body updates the collision detection data for all shapes attached to a body.
@[inline]
pub fn (mut space Space) reindex_shapes_for_body(body &Body) {
	C.cpSpaceReindexShapesForBody(space, body)
}

// C signature:
// CP_EXPORT void cpSpaceUseSpatialHash(cpSpace *space, cpFloat dim, int count);
fn C.cpSpaceUseSpatialHash(space &C.cpSpace, dim Float, count int)

// use_spatial_hash switchs the space to use a spatial has as it's spatial index.
@[inline]
pub fn (mut space Space) use_spatial_hash(dim Float, count int) {
	C.cpSpaceUseSpatialHash(space, dim, count)
}

// C signature:
// CP_EXPORT void cpSpaceStep(cpSpace *space, cpFloat dt);
fn C.cpSpaceStep(space &C.cpSpace, dt Float)

// step steps the space forward in time by @c dt.
@[inline]
pub fn (mut space Space) step(dt Float) {
	C.cpSpaceStep(space, dt)
}

@[typedef]
struct C.cpSpaceDebugColor {}

pub type SpaceDebugColor = C.cpSpaceDebugColor

@[typedef]
struct C.cpSpaceDebugDrawOptions {}

pub type SpaceDebugDrawOptions = C.cpSpaceDebugDrawOptions

// C signature:
// CP_EXPORT void cpSpaceDebugDraw(cpSpace *space, cpSpaceDebugDrawOptions *options);
fn C.cpSpaceDebugDraw(space &C.cpSpace, options &C.cpSpaceDebugDrawOptions)

// debug_draw debugs draw the current state of the space using the supplied drawing options.
@[inline]
pub fn (mut space Space) debug_draw(options &C.cpSpaceDebugDrawOptions) {
	C.cpSpaceDebugDraw(space, options)
}

//
// cpSpatialIndex.h
//

@[typedef]
struct C.cpSpatialIndexClass {}

pub type SpatialIndexClass = C.cpSpatialIndexClass

@[typedef]
struct C.cpSpatialIndex {}

pub type SpatialIndex = C.cpSpatialIndex

@[typedef]
struct C.cpSpaceHash {}

pub type SpaceHash = C.cpSpaceHash

// C signature:
// CP_EXPORT cpSpaceHash* cpSpaceHashAlloc();
fn C.cpSpaceHashAlloc() &C.cpSpaceHash

// space_hash_alloc allocates a spatial hash.
@[inline]
pub fn space_hash_alloc() &SpaceHash {
	return C.cpSpaceHashAlloc()
}

// C signature:
// CP_EXPORT cpSpatialIndex* cpSpaceHashInit(cpSpaceHash *hash, cpFloat celldim, int numcells, cpSpatialIndexBBFunc bbfunc, cpSpatialIndex *staticIndex);
fn C.cpSpaceHashInit(hash &C.cpSpaceHash, celldim Float, numcells int, bbfunc C.cpSpatialIndexBBFunc, staticIndex &C.cpSpatialIndex) &C.cpSpatialIndex

// init initializes a spatial hash.
@[inline]
pub fn (mut hash SpaceHash) init(celldim Float, numcells int, bbfunc C.cpSpatialIndexBBFunc, staticIndex &C.cpSpatialIndex) &C.cpSpatialIndex {
	return C.cpSpaceHashInit(hash, celldim, numcells, bbfunc, staticIndex)
}

// C signature:
// CP_EXPORT cpSpatialIndex* cpSpaceHashNew(cpFloat celldim, int cells, cpSpatialIndexBBFunc bbfunc, cpSpatialIndex *staticIndex);
fn C.cpSpaceHashNew(celldim Float, cells int, bbfunc C.cpSpatialIndexBBFunc, staticIndex &C.cpSpatialIndex) &C.cpSpatialIndex

// space_hash_new allocates and initialize a spatial hash.
@[inline]
pub fn space_hash_new(celldim Float, cells int, bbfunc C.cpSpatialIndexBBFunc, staticIndex &C.cpSpatialIndex) &C.cpSpatialIndex {
	return C.cpSpaceHashNew(celldim, cells, bbfunc, staticIndex)
}

// C signature:
// CP_EXPORT void cpSpaceHashResize(cpSpaceHash *hash, cpFloat celldim, int numcells);
fn C.cpSpaceHashResize(hash &C.cpSpaceHash, celldim Float, numcells int)

// resize changes the cell dimensions and table size of the spatial hash to tune it.
// The cell dimensions should roughly match the average size of your objects
// and the table size should be ~10 larger than the number of objects inserted.
// Some trial and error is required to find the optimum numbers for efficiency.
@[inline]
pub fn (mut hash SpaceHash) resize(celldim Float, numcells int) {
	C.cpSpaceHashResize(hash, celldim, numcells)
}

@[typedef]
struct C.cpBBTree {}

pub type BBTree = C.cpBBTree

// C signature:
// CP_EXPORT cpBBTree* cpBBTreeAlloc();
fn C.cpBBTreeAlloc() &C.cpBBTree

// bb_tree_alloc allocates a bounding box tree.
@[inline]
pub fn bb_tree_alloc() &C.cpBBTree {
	return C.cpBBTreeAlloc()
}

// C signature:
// CP_EXPORT cpSpatialIndex* cpBBTreeInit(cpBBTree *tree, cpSpatialIndexBBFunc bbfunc, cpSpatialIndex *staticIndex);
fn C.cpBBTreeInit(tree &C.cpBBTree, bbfunc C.cpSpatialIndexBBFunc, staticIndex &C.cpSpatialIndex) &C.cpSpatialIndex

// bb_tree_init initializes a bounding box tree.
@[inline]
pub fn bb_tree_init(tree &C.cpBBTree, bbfunc C.cpSpatialIndexBBFunc, staticIndex &C.cpSpatialIndex) &C.cpSpatialIndex {
	return C.cpBBTreeInit(tree, bbfunc, staticIndex)
}

// C signature:
// CP_EXPORT cpSpatialIndex* cpBBTreeNew(cpSpatialIndexBBFunc bbfunc, cpSpatialIndex *staticIndex);
fn C.cpBBTreeNew(bbfunc C.cpSpatialIndexBBFunc, staticIndex &C.cpSpatialIndex) &C.cpSpatialIndex

// bb_tree_new allocates and initialize a bounding box tree.
@[inline]
pub fn bb_tree_new(bbfunc C.cpSpatialIndexBBFunc, staticIndex &C.cpSpatialIndex) &C.cpSpatialIndex {
	return C.cpBBTreeNew(bbfunc, staticIndex)
}

// C signature:
// CP_EXPORT void cpBBTreeOptimize(cpSpatialIndex *index);
fn C.cpBBTreeOptimize(index &C.cpSpatialIndex)

// bb_tree_optimize performs a static top down optimization of the tree.
@[inline]
pub fn bb_tree_optimize(index &C.cpSpatialIndex) {
	C.cpBBTreeOptimize(index)
}

// C signature:
// CP_EXPORT void cpBBTreeSetVelocityFunc(cpSpatialIndex *index, cpBBTreeVelocityFunc func);
fn C.cpBBTreeSetVelocityFunc(index &C.cpSpatialIndex, func C.cpBBTreeVelocityFunc)

// bb_tree_set_velocity_func sets the velocity function for the bounding box tree to enable temporal coherence.
@[inline]
pub fn bb_tree_set_velocity_func(index &C.cpSpatialIndex, func C.cpBBTreeVelocityFunc) {
	C.cpBBTreeSetVelocityFunc(index, func)
}

@[typedef]
struct C.cpSweep1D {}

pub type Sweep1D = C.cpSweep1D

// C signature:
// CP_EXPORT cpSweep1D* cpSweep1DAlloc();
fn C.cpSweep1DAlloc() &C.cpSweep1D

// sweep1d_alloc allocates a 1D sort and sweep broadphase.
@[inline]
pub fn sweep1d_alloc() &Sweep1D {
	return C.cpSweep1DAlloc()
}

// C signature:
// CP_EXPORT cpSpatialIndex* cpSweep1DInit(cpSweep1D *sweep, cpSpatialIndexBBFunc bbfunc, cpSpatialIndex *staticIndex);
fn C.cpSweep1DInit(sweep &C.cpSweep1D, bbfunc C.cpSpatialIndexBBFunc, staticIndex &C.cpSpatialIndex) &C.cpSpatialIndex

// init initializes a 1D sort and sweep broadphase.
@[inline]
pub fn (mut sweep Sweep1D) init(bbfunc C.cpSpatialIndexBBFunc, staticIndex &C.cpSpatialIndex) &C.cpSpatialIndex {
	return C.cpSweep1DInit(sweep, bbfunc, staticIndex)
}

// C signature:
// CP_EXPORT cpSpatialIndex* cpSweep1DNew(cpSpatialIndexBBFunc bbfunc, cpSpatialIndex *staticIndex);
fn C.cpSweep1DNew(bbfunc C.cpSpatialIndexBBFunc, staticIndex &C.cpSpatialIndex) &C.cpSpatialIndex

// sweep1d_new allocates and initialize a 1D sort and sweep broadphase.
@[inline]
pub fn sweep1d_new(bbfunc C.cpSpatialIndexBBFunc, staticIndex &C.cpSpatialIndex) &C.cpSpatialIndex {
	return C.cpSweep1DNew(bbfunc, staticIndex)
}

// C signature:
// CP_EXPORT void cpSpatialIndexFree(cpSpatialIndex *index);
fn C.cpSpatialIndexFree(index &C.cpSpatialIndex)

// spatial_index_free destroys and free a spatial index.
@[inline]
pub fn spatial_index_free(index &C.cpSpatialIndex) {
	C.cpSpatialIndexFree(index)
}

// C signature:
// CP_EXPORT void cpSpatialIndexCollideStatic(cpSpatialIndex *dynamicIndex, cpSpatialIndex *staticIndex, cpSpatialIndexQueryFunc func, void *data);
fn C.cpSpatialIndexCollideStatic(dynamicIndex &C.cpSpatialIndex, staticIndex &C.cpSpatialIndex, func C.cpSpatialIndexQueryFunc, data voidptr)

// spatial_index_collide_static collides the objects in @c dynamicIndex against the objects in @c staticIndex using the query callback function.
@[inline]
pub fn spatial_index_collide_static(dynamicIndex &C.cpSpatialIndex, staticIndex &C.cpSpatialIndex, func C.cpSpatialIndexQueryFunc, data &C.void) {
	C.cpSpatialIndexCollideStatic(dynamicIndex, staticIndex, func, data)
}

//
// cpTransform.h
//

//
// cpVect.h
//
